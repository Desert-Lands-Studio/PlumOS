ğŸ“ arch
    ğŸ“ aarch64
        ğŸ“ boot
            ğŸ“ baremetal
                ğŸ“„ start.S
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                .section ".text.boot"
                .global _start
                .type _start, @function
                
                _start:
                    ldr x30, =__stack_top
                    mov sp, x30
                
                    ldr x0, =__bss_start
                    ldr x1, =__bss_end
                    cmp x1, x0
                    beq 2f
                1:
                    str xzr, [x0], #8
                    cmp x0, x1
                    blt 1b
                2:
                    bl _start_rust
                
                halt:
                    wfi
                    b halt                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“ uefi
                ğŸ“„ entry.S
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                .global efi_main
                
                efi_main:
                    mov x19, x0  
                    mov x20, x1  
                
                    
                    bl uefi_init
                
                    mov x0, x19
                    mov x1, x20
                    bl rust_loader_entry
                
                    
                    b .
                
                uefi_init:
                    
                    ret                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mmio.c
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        #include <stdint.h>
        
        #define UART_BASE 0x09000000UL
        
        static inline void mmio_write(uint32_t reg, uint32_t data) {
            *(volatile uint32_t *)((uintptr_t)UART_BASE + reg) = data;
        }
        
        static inline uint32_t mmio_read(uint32_t reg) {
            return *(volatile uint32_t *)((uintptr_t)UART_BASE + reg);
        }
        
        void uart_init() {
            // ĞÑ‚ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ UART Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¾Ğ¹
            mmio_write(0x30, 0x00);
            // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ: IBRD = 16 (3.6864 MHz / (16 * 115200) = 2)
            mmio_write(0x24, 0x02);
            mmio_write(0x28, 0x00); // FBRD = 0
            // 8N1, FIFO Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹
            mmio_write(0x2C, (1 << 4) | (3 << 5)); // LCR_H
            // Ğ’ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ UART, TX, RX
            mmio_write(0x30, (1 << 0) | (1 << 8) | (1 << 9)); // CR
        }
        
        void uart_putc(char c) {
            while (mmio_read(0x18) & 0x20);
            mmio_write(0x00, c);
        }
        
        void uart_puts(const char *s) {
            while (*s) uart_putc(*s++);
        }
        
        void memzero(void *ptr, unsigned long size) {
            uint8_t *p = (uint8_t*)ptr;
            for (unsigned long i = 0; i < size; i++) {
                p[i] = 0;
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ riscv64
        ğŸ“ boot
            ğŸ“„ start.S
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            .section ".text.init"
            .global _start
            _start:
                la sp, __stack_top
            
                # ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° BSS
                la a0, __bss_start
                la a1, __bss_end
                sub a1, a1, a0
                call memzero
            
                # Ğ’Ñ‹Ğ·Ğ¾Ğ² Rust entry
                li a0, 0  # argc
                li a1, 0  # argv
                call bootloader_main
            
            halt:
                wfi
                j halt
            
            boot_message:
                .asciz "RISCV64 Minimal Bootloader Initialized!\n"
            
            .section ".bss"
                .align 4
                .skip 0x4000
            __stack_top:            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ clint.c
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        #include <stdint.h>
        
        
        #define CLINT_BASE 0x2000000UL
        #define CLINT_MTIMECMP (CLINT_BASE + 0x4000)
        #define CLINT_MTIME (CLINT_BASE + 0xbff8)
        
        static inline void clint_write(uint64_t reg, uint64_t data) {
            *(volatile uint64_t *)(reg) = data;
        }
        
        static inline uint64_t clint_read(uint64_t reg) {
            return *(volatile uint64_t *)(reg);
        }
        
        void clint_init() {
            
            clint_write(CLINT_MTIMECMP, clint_read(CLINT_MTIME) + 1000000); 
        }
        
        uint64_t clint_get_time() {
            return clint_read(CLINT_MTIME);
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ x86_64
        ğŸ“ boot
            ğŸ“ bios
                ğŸ“„ mbr.S
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                .code16
                .intel_syntax noprefix
                
                .global start
                start:
                    jmp short start_stage2
                
                .balign 512, 0x0
                
                start_stage2:
                    cli 
                    cld 
                
                    xor ax, ax
                    mov ds, ax
                    mov es, ax
                    mov ss, ax
                    mov sp, 0x7c00
                
                    mov ah, 0x0e
                    mov bh, 0x00
                    mov bl, 0x07
                
                    mov si, offset msg
                print_char:
                    lodsb
                    or al, al
                    jz end_boot
                    int 0x10
                    jmp print_char
                
                end_boot:
                    jmp $
                
                msg:
                   .ascii "x86_64 BIOS MBR Bootloader Initialized!\n"
                   .byte 0
                
                .org 510
                .word 0xaa55                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ stage2.c
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                #include <stdint.h>
                
                void print_char(char c) {
                    asm volatile (
                        "mov $0x0e, %%ah\n"
                        "mov $0x00, %%bh\n"
                        "mov %0, %%al\n"
                        "int $0x10"
                        : : "r"(c) : "ax", "bx"
                    );
                }
                
                void print_string(const char *str) {
                    while (*str) {
                        print_char(*str);
                        str++;
                    }
                }
                
                void load_kernel() {
                    print_string("Loading kernel...\r\n");
                }
                
                int main() {
                    print_string("Stage 2 loaded!\r\n");
                    load_kernel();
                    asm volatile ("jmp 0x1000");
                    return 0;
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“ uefi
                ğŸ“„ entry.c
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                #include <efi.h>
                #include <efilib.h>
                
                extern EFI_STATUS efi_load_and_run_kernel(EFI_HANDLE, EFI_SYSTEM_TABLE*);
                
                EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
                    InitializeLib(ImageHandle, SystemTable);
                    Print(L"PlumOS Bootloader\n");
                    return efi_load_and_run_kernel(ImageHandle, SystemTable);
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ gdt.S
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        .global gdt_load
        
        gdt:
            .quad 0x0000000000000000  
            .quad 0x00af9b000000ffff  
            .quad 0x00af93000000ffff  
        
        gdt_ptr:
            .word gdt_ptr - gdt - 1
            .quad gdt
        
        gdt_load:
            lgdt [gdt_ptr]
            ret        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ idt.S
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        .global idt_load
        
        idt:
            .fill 256, 8, 0  
        
        idt_ptr:
            .word idt_ptr - idt - 1
            .quad idt
        
        idt_load:
            lidt [idt_ptr]
            ret        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“„ Cargo.toml
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[package]
name = "bootloader"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "bootloader"
path = "src/main.rs"
test = false
bench = false

[dependencies]
spin = "0.10.0"
linked_list_allocator = "0.10.5"
plum-hal = { path = "../sdk/lib/plum-hal" }
plum-formats = { path = "../sdk/lib/plum-formats" }
itoa = { version = "1.0.15", default-features = false }
log = "0.4.28"

[build-dependencies]
cc = "1.2.41"

[features]
default = ["minimal"]
minimal = []
full = ["graphics", "network", "secure_boot"]
graphics = []
network = []
secure_boot = []
uefi = ["plum-hal/uefi"]
bios = []
prum64 = []
aarch64 = []
x86_64 = []
riscv64 = []

[package.metadata.bootloader]
default_target = "aarch64-unknown-none"
targets = ["aarch64-unknown-none", "x86_64-unknown-none", "riscv64-unknown-none"]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ config
    ğŸ“„ boot.cfg
    [binary file skipped]
ğŸ“ linkers
    ğŸ“„ aarch64.ld
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ENTRY(_start)
    
    MEMORY {
        RAM (rwx) : ORIGIN = 0x40000000, LENGTH = 128M
    }
    
    SECTIONS {
        . = 0x40000000;
        
        .text.boot : {
            *(.text.boot)
        } > RAM
        
        .text : {
            *(.text .text.*)
        } > RAM
        
        .rodata : {
            *(.rodata .rodata.*)
        } > RAM
        
        .data : {
            *(.data .data.*)
        } > RAM
        
        .bss : {
            __bss_start = .;
            *(.bss .bss.*)
            *(COMMON)
            __bss_end = .;
        } > RAM
        
        . = ALIGN(16);
        __stack_bottom = .;
        . = . + 0x10000;
        __stack_top = .;
        
        /DISCARD/ : {
            *(.comment)
            *(.note.*)
        }
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ prum64.ld
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ENTRY(_start)
    
    MEMORY {
        RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 256M
    }
    
    SECTIONS {
        . = 0x80000000;
    
        .text : {
            KEEP(*(.text.boot))
            *(.text .text.*)
        } > RAM
    
        .rodata : {
            *(.rodata .rodata.*)
        } > RAM
    
        .data : {
            *(.data .data.*)
        } > RAM
    
        .bss : {
            __bss_start = .;
            *(.bss .bss.*)
            *(COMMON)
            __bss_end = .;
        } > RAM
    
        . = ALIGN(16);
        __stack_top = . + 0x20000; /* 128KB ÑÑ‚ĞµĞº */
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ riscv64.ld
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ENTRY(_start)
    
    MEMORY {
        RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 128M
    }
    
    SECTIONS {
        .text : {
            *(.text.init)
            *(.text*)
        } > RAM
    
        .rodata : {
            *(.rodata*)
        } > RAM
    
        .data : {
            *(.data*)
        } > RAM
    
        .bss : {
            __bss_start = .;
            *(.bss*)
            __bss_end = .;
        } > RAM
    
        . = ALIGN(16);
        __stack_top = . + 16*1024;
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ x86_64-bios.ld
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ENTRY(start)
    
    SECTIONS {
        . = 0x7c00;
        .text : {
            *(.text*)
        }
    
        .rodata : {
            *(.rodata*)
        }
    
        .data : {
            *(.data*)
        }
    
        .bss : {
            __bss_start = .;
            *(.bss*)
            __bss_end = .;
        }
    
        /DISCARD/ : {
            *(.eh_frame)
            *(.comment)
        }
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ x86_64-uefi.ld
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ENTRY(_start)
    
    SECTIONS {
        . = 0x0;
    
        .text : {
            KEEP(*(.text.boot))
            *(.text*)
        }
    
        .rodata : {
            *(.rodata*)
        }
    
        .data : {
            __data_start = .;
            *(.data*)
            __data_end = .;
        }
    
        .bss (NOLOAD) : {
            __bss_start = .;
            *(.bss*)
            *(COMMON)
            __bss_end = .;
        }
    
        /DISCARD/ : {
            *(.eh_frame)
            *(.comment)
            *(.debug*)
        }
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ src
    ğŸ“ alloc
        ğŸ“„ early_alloc.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        use core::ptr;
        use spin::Mutex;
        
        pub struct StackAllocator {
            start: usize,
            end: usize,
            current: usize,
        }
        
        impl StackAllocator {
            pub const fn new(start: usize, size: usize) -> Self {
                Self {
                    start,
                    end: start + size,
                    current: start,
                }
            }
        
            pub fn allocate(&mut self, size: usize, align: usize) -> Option<*mut u8> {
                let aligned_addr = (self.current + align - 1) & !(align - 1);
                if aligned_addr + size <= self.end {
                    let ptr = aligned_addr as *mut u8;
                    self.current = aligned_addr + size;
                    Some(ptr)
                } else {
                    None
                }
            }
        
            pub fn allocate_zeroed(&mut self, size: usize, align: usize) -> Option<*mut u8> {
                self.allocate(size, align).map(|ptr| {
                    unsafe { ptr::write_bytes(ptr, 0, size) };
                    ptr
                })
            }
        
            pub fn reset(&mut self) {
                self.current = self.start;
            }
        
            pub fn used(&self) -> usize {
                self.current - self.start
            }
        
            pub fn available(&self) -> usize {
                self.end - self.current
            }
        }
        
        pub static STACK_ALLOC: Mutex<StackAllocator> =
            Mutex::new(StackAllocator::new(0x4100_0000, 64 * 1024));
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod early_alloc;
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ api
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod panic_handler;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ panic_handler.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        use core::panic::PanicInfo;
        
        #[panic_handler]
        fn panic(info: &PanicInfo) -> ! {
            crate::hal::Console::puts("KERNEL PANIC: ");
            if let Some(location) = info.location() {
                crate::hal::Console::puts(location.file());
                crate::hal::Console::puts(":");
                crate::hal::Console::puts(itoa::Buffer::new().format(location.line()));
            }
            crate::hal::Console::puts("\n");
        
            if let Some(_args) = info.message().as_str() {
                use core::fmt::Write;
                let mut writer = crate::hal::console::ConsoleWriter;
                let _ = write!(&mut writer, "{}", info.message());
            }
        
            crate::halt();
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ arch
        ğŸ“ aarch64
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use crate::arch::{Arch, KernelInfo};
            pub struct AArch64;
            
            impl Arch for AArch64 {
                fn get_kernel_info() -> KernelInfo {
                    KernelInfo {
                        entry_point: 0x40080000,
                        memory_map: &[],
                        cmdline: "console=ttyAMA0",
                        #[cfg(target_arch = "aarch64")]
                        device_tree_ptr: Some(0x40000000),
                        #[cfg(not(target_arch = "aarch64"))]
                        device_tree_ptr: None,
                    }
                }
            
                fn jump_to_kernel(info: KernelInfo) -> ! {
                    unsafe {
                        #[cfg(target_arch = "aarch64")]
                        {
                            if let Some(dtb) = info.device_tree_ptr {
                                core::arch::asm!(
                                    "mov x0, {dtb}",
                                    "br {entry}",
                                    dtb = in(reg) dtb,
                                    entry = in(reg) info.entry_point,
                                    options(noreturn)
                                );
                            } else {
                                core::arch::asm!(
                                    "br {entry}",
                                    entry = in(reg) info.entry_point,
                                    options(noreturn)
                                );
                            }
                        }
                        #[cfg(not(target_arch = "aarch64"))]
                        {
                            core::arch::asm!(
                                "jmp {entry}",
                                entry = in(reg) info.entry_point,
                                options(noreturn)
                            );
                        }
                    }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        #[cfg(target_arch = "aarch64")]
        pub mod aarch64;
        #[cfg(target_arch = "x86_64")]
        pub mod x86_64;
        #[cfg(target_arch = "riscv64")]
        pub mod riscv64;
        
        pub struct KernelInfo {
            pub entry_point: usize,
            pub memory_map: &'static [u8],
            pub cmdline: &'static str,
            pub device_tree_ptr: Option<usize>,
        }
        
        pub trait Arch {
            fn get_kernel_info() -> KernelInfo;
            fn jump_to_kernel(info: KernelInfo) -> !;
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ riscv64
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use super::Arch;
            use super::KernelInfo;
            
            pub struct RiscV64;
            
            impl Arch for RiscV64 {
                fn init_early() {
                    
                    
                    unsafe {
                        clint_init();
                    }
                }
                
                fn init_memory() {
                    
                }
                
                fn get_kernel_info() -> KernelInfo {
                    KernelInfo {
                        entry_point: 0x80000000, 
                        memory_map: &[],
                        cmdline: "console=ttyS0",
                    }
                }
                
                fn jump_to_kernel() -> ! {
                    let info = Self::get_kernel_info();
                    unsafe {
                        core::arch::asm!(
                            "jr {}",
                            in(reg) info.entry_point,
                            options(noreturn)
                        );
                    }
                }
            }
            
            
            extern "C" {
                fn clint_init();
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ x86_64
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use super::Arch;
            use super::KernelInfo;
            
            pub struct X86_64;
            
            impl Arch for X86_64 {
                fn init_early() {
                    
                    
                    unsafe {
                        gdt_load();
                        idt_load();
                    }
                }
                
                fn init_memory() {
                    
                }
                
                fn get_kernel_info() -> KernelInfo {
                    KernelInfo {
                        entry_point: 0x100000, 
                        memory_map: &[],
                        cmdline: "console=ttyS0",
                    }
                }
                
                fn jump_to_kernel() -> ! {
                    let info = Self::get_kernel_info();
                    unsafe {
                        core::arch::asm!(
                            "jmp {}",
                            in(reg) info.entry_point,
                            options(noreturn)
                        );
                    }
                }
            }
            
            
            extern "C" {
                fn gdt_load();
                fn idt_load();
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ boot
        ğŸ“„ baremetal.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        #![no_std]
        #![no_main]
        #![feature(alloc_error_handler)]
        
        use core::fmt::Write;
        use core::ptr;
        
        use plum_formats::plam::{PlamHeader, PLAM_MAGIC}; // Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ² crate plum_formats ĞµÑÑ‚ÑŒ plam
        use plum_hal::console::ConsoleWriter; // Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ConsoleWriter Ğ¸Ğ· plum-hal
        
        /// ĞĞ´Ñ€ĞµÑ, Ğ¿Ğ¾ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼Ñƒ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ÑÑ PLAM-Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº.
        /// ĞŸĞ¾Ğ´ÑÑ‚Ğ°Ğ²ÑŒ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ´Ñ€ĞµÑ Ğ´Ğ»Ñ ÑĞ²Ğ¾ĞµĞ¹ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñ‹.
        const PLAM_LOAD_ADDR: usize = 0x8000_0000usize; // Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ â€” Ğ¿Ğ¾Ğ¼ĞµĞ½ÑĞ¹ Ğ¿Ğ¾Ğ´ ÑĞ²Ğ¾Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ
        
        /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼Ğ¾Ğ³Ğ¾ ÑĞ´Ñ€Ğ° (Ğ¿Ñ€ĞµĞ´Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒ).
        const MAX_KERNEL_SIZE: usize = 32 * 1024 * 1024; // 32 MiB, Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€
        
        /// ĞŸÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ°Ñ Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ ÑĞ´Ñ€Ğ°.
        /// ĞŸĞ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ‹Ñ‚Ğ°ĞµÑ‚ÑÑ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ PLAM; Ğ¿Ğ¾Ğ·Ğ¶Ğµ ÑÑĞ´Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°.
        pub fn load_kernel() -> Result<usize, &'static str> {
            // Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ´ĞµĞ»ĞµĞ³Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ PLAM.
            match load_kernel_plam() {
                Ok(addr) => Ok(addr),
                Err(e) => {
                    // Ğ¡Ğ¾Ğ¾Ğ±Ñ‰Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ.
                    let mut w = ConsoleWriter;
                    let _ = write!(&mut w, "bootloader: plam loader failed: {}\n", e);
                    // Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñ‹ Ğ·Ğ´ĞµÑÑŒ Ğ² Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞ¼:
                    // load_kernel_elf() or others.
                    Err(e)
                }
            }
        }
        
        /// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ PLAM-Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ°.
        /// ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ° Ğ¸ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ°Ğ´Ñ€ĞµÑĞ° ÑÑ‚Ğ°Ñ€Ñ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑĞµĞºÑ‚Ğ¾Ñ€Ğ°/ÑĞ´Ñ€Ğ°.
        fn load_kernel_plam() -> Result<usize, &'static str> {
            // Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾.
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: attempting to load .plam from {:#x}\n", PLAM_LOAD_ADDR);
        
            // ĞœÑ‹ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ¸Ğ· Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¿Ğ¾ PLAM_LOAD_ADDR.
            // ĞŸĞ¾ÑĞºĞ¾Ğ»ÑŒĞºÑƒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ ÑÑ‹Ñ€Ñ‹Ğ¼Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸ â€” unsafe, Ğ¾Ğ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼.
            unsafe {
                let header_ptr = PLAM_LOAD_ADDR as *const PlamHeader;
        
                // ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ header (Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒĞµÑ‚ UB, ĞµÑĞ»Ğ¸ Ğ°Ğ´Ñ€ĞµÑ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹).
                // Ğ—Ğ´ĞµÑÑŒ Ğ´ĞµĞ»Ğ°ĞµĞ¼ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ: Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ magic Ğ¸ cpu id/size.
                let header = ptr::read_unaligned(header_ptr);
        
                // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¼Ğ°Ğ³Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ°
                if header.magic != PLAM_MAGIC {
                    let _ = write!(
                        &mut w,
                        "bootloader: plam magic mismatch: found {:#x}, expected {:#x}\n",
                        header.magic, PLAM_MAGIC
                    );
                    return Err("invalid plam magic");
                }
        
                // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹ (Ğ´Ğ»Ñ AArch64)
                if header.cpu != PLAM_CPU_ARM64 {
                    let _ = write!(
                        &mut w,
                        "bootloader: plam cpu mismatch: found {:#x}, expected {:#x}\n",
                        header.cpu, PLAM_CPU_ARM64
                    );
                    return Err("invalid plam cpu arch");
                }
        
                // ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğµ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€
                if header.totalsize == 0 || (header.totalsize as usize) > MAX_KERNEL_SIZE {
                    let _ = write!(
                        &mut w,
                        "bootloader: plam image size invalid: {}\n",
                        header.totalsize
                    );
                    return Err("invalid plam image size");
                }
        
                // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°Ğ´Ñ€ĞµÑĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸/ÑĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ entry_offset Ğ¸Ğ· Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ°)
                let entry_offset = header.entry_offset as usize;
                let image_base = header.image_base as usize;
                let entry_addr = image_base.checked_add(entry_offset).ok_or("entry addr overflow")?;
        
                // Ğ—Ğ´ĞµÑÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ (checksum, signature, etc.)
                // Ğ¢Ğ°ĞºĞ¶Ğµ â€” Ğ´ĞµĞºĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸Ñ/Ñ€ĞµĞ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ, ĞµÑĞ»Ğ¸ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ (stub Ğ¿Ğ¾ĞºĞ°).
                // ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ· ÑƒĞ¶Ğµ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ².
        
                let _ = write!(
                    &mut w,
                    "bootloader: plam header ok; entry at {:#x}, size {}\n",
                    entry_addr, header.totalsize
                );
        
                Ok(entry_addr)
            }
        }
        
        /// Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°: COFF
        fn load_kernel_coff() -> Result<usize, &'static str> {
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: COFF loader not implemented\n");
            Err("coff loader not implemented")
        }
        
        /// Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°: PE
        fn load_kernel_pe() -> Result<usize, &'static str> {
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: PE loader not implemented\n");
            Err("pe loader not implemented")
        }
        
        /// Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°: ELF
        fn load_kernel_elf() -> Result<usize, &'static str> {
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: ELF loader not implemented\n");
            Err("elf loader not implemented")
        }
        
        /// Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°: Mach-O
        fn load_kernel_macho() -> Result<usize, &'static str> {
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: Mach-O loader not implemented\n");
            Err("macho loader not implemented")
        }
        
        /// Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ Ğ´Ğ»Ñ hal/logger â€” ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ½Ğ°Ğ´Ğ¾Ğ±Ğ¸Ñ‚ÑÑ, Ğ·Ğ´ĞµÑÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ²ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸.
        /// ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ `halt` (diverging), ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¸ Ğ¤Ğ°Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ.
        #[allow(dead_code)]
        fn halt() -> ! {
            let mut w = ConsoleWriter;
            let _ = write!(&mut w, "bootloader: halt\n");
            loop {
                // ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµĞ¼ â€” Ğ¾ÑÑ‚Ğ°Ñ‘Ğ¼ÑÑ Ğ² Ğ±ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ¾Ğ¼ Ñ†Ğ¸ĞºĞ»Ğµ.
                core::hint::spin_loop();
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ chain.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        use plum_formats::plam::PlamHeader;
        use crate::fs::fat32::Fat32Fs;
        
        pub fn chain_load_kernel(fs: &Fat32Fs) -> ! {
            
            let kernel_data = fs.read_file("/boot/kernel.plam").expect("Kernel not found");
        
            
            let header = unsafe { &*(kernel_data.as_ptr() as *const PlamHeader) };
            if header.magic != 0x504C414D {
                panic!("Invalid PLAM magic");
            }
        
            
            
            let entry = (header.image_base + header.entry_offset) as *const ();
            let entry_fn: fn() -> ! = unsafe { core::mem::transmute(entry) };
            entry_fn();
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod baremetal;
        pub mod chain;
        pub mod protocols;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ protocols
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub mod multiboot2;
            pub mod ofw;
            pub mod uefi;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ multiboot2.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub struct MultibootInfo {
                
            }
            
            pub fn parse_multiboot(magic: u32, _addr: usize) -> Option<MultibootInfo> {
                if magic != 0x36d76289 {
                    None
                } else {
                    
                    Some(MultibootInfo {})
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ ofw.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub fn ofw_init() {
                
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ uefi.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #![cfg(feature = "uefi")]
            
            use uefi::prelude::*;
            use uefi::proto::media::file::{File, FileAttribute, FileMode, FileInfo};
            use uefi::boot::{self, AllocateType, MemoryType};
            use uefi::CStr16;
            use uefi::Status;
            
            use crate::formats::plam::load_plam;
            
            extern "C" {
                fn init_c();
            }
            
            
            const MAX_KERNEL_SIZE: usize = 16 * 1024 * 1024;
            
            #[entry]
            pub extern "efiapi" fn efi_main(
                image_handle: Handle,
                system_table: *mut SystemTable<Boot>,
            ) -> Status {
                unsafe { init_c(); }
            
                
                let st = unsafe { &mut *system_table };
                uefi::helpers::init(image_handle, st).expect("Failed to initialize UEFI");
            
                st.stdout().clear().unwrap();
                st.stdout().write_str("PlumOS UEFI Bootloader\n").unwrap();
            
                
                let fs_proto = boot::get_image_file_system(image_handle).unwrap();
                let mut fs = unsafe { &mut *fs_proto.get() };
            
                
                let mut root = fs.open_volume().unwrap();
            
                
                let kernel_path = CStr16::from_str_with_buf("kernel.plam", &mut [0u16; 32]).unwrap();
                let mut file = root.open(kernel_path, FileMode::Read, FileAttribute::empty()).unwrap();
            
                
                let info = file.get_boxed_info::<FileInfo>().unwrap();
                let size = info.file_size() as usize;
                if size > MAX_KERNEL_SIZE {
                    st.stdout().write_str("Kernel too large!\n").unwrap();
                    return Status::LOAD_ERROR;
                }
            
                
                let pages = (size + 4095) / 4096;
                let kernel_addr = boot::allocate_pages(
                    AllocateType::AnyPages,
                    MemoryType::LOADER_DATA,
                    pages,
                ).unwrap().as_ptr() as usize;
            
                
                let mut buffer = [0u8; MAX_KERNEL_SIZE];
                let read_size = file.read(&mut buffer[..size]).unwrap();
                if read_size != size {
                    return Status::LOAD_ERROR;
                }
            
                
                unsafe {
                    core::ptr::copy_nonoverlapping(buffer.as_ptr(), kernel_addr as *mut u8, size);
                }
            
                
                let entry = load_plam(unsafe { core::slice::from_raw_parts(kernel_addr as *const u8, size) }, kernel_addr);
            
                
                let entry_fn: extern "C" fn() -> ! = unsafe { core::mem::transmute(entry) };
                entry_fn();
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ build.rs
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    use std::env;
    
    fn main() {
        let target = env::var("TARGET").unwrap();
    
        match target.as_str() {
            "aarch64-unknown-none" => compile_aarch64(),
            "riscv64-unknown-none" => compile_riscv64(),
            _ => {}
        }
    
        println!("cargo:rerun-if-changed=arch/");
    }
    
    fn compile_aarch64() {
        cc::Build::new()
            .compiler("clang")
            .file("arch/aarch64/boot/baremetal/start.S")
            .flag("-target")
            .flag("aarch64-unknown-none")
            .compile("aarch64-start");
    
        cc::Build::new()
            .compiler("clang")
            .file("arch/aarch64/mmio.c")
            .flag("-target")
            .flag("aarch64-unknown-none")
            .flag("-ffreestanding")
            .compile("aarch64-mmio");
    
        println!("cargo:rerun-if-changed=arch/aarch64/boot/baremetal/start.S");
        println!("cargo:rerun-if-changed=arch/aarch64/mmio.c");
    }
    
    fn compile_riscv64() {
        cc::Build::new()
            .file("arch/riscv64/clint.c")
            .target("riscv64-none-elf")
            .flag("-ffreestanding")
            .compile("riscv64-clint");
            
        println!("cargo:rerun-if-changed=arch/riscv64/clint.c");
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ features.rs
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    use core::sync::atomic::{AtomicU32, Ordering};
    
    static ENABLED_FEATURES: AtomicU32 = AtomicU32::new(0);
    
    #[repr(u32)]
    #[derive(Clone, Copy)]
    pub enum Feature {
        Graphics = 1 << 0,
        Network = 1 << 1,
        SecureBoot = 1 << 2,
        FileSystems = 1 << 3,
        Multiboot = 1 << 4,
        UEFI = 1 << 5,
    }
    
    impl Feature {
        pub fn enable(self) {
            ENABLED_FEATURES.fetch_or(self as u32, Ordering::SeqCst);
        }
    
        pub fn disable(self) {
            ENABLED_FEATURES.fetch_and(!(self as u32), Ordering::SeqCst);
        }
    
        pub fn is_enabled(self) -> bool {
            ENABLED_FEATURES.load(Ordering::SeqCst) & (self as u32) != 0
        }
    }
    
    #[macro_export]
    macro_rules! with_feature {
        ($feature:expr, $code:block) => {
            if $feature.is_enabled() {
                $code
            }
        };
    }
    
    pub fn init_features() {
        Feature::FileSystems.enable();
        Feature::Multiboot.enable();
    }
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ fs
        ğŸ“„ apfs.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Apfs {
            
        }
        
        impl Apfs {
            pub fn new() -> Self {
                Apfs {}
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ btrfs.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Btrfs {
            
        }
        
        impl Btrfs {
            pub fn new() -> Self {
                Btrfs {}
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ ext4.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Ext4Fs {
            
        }
        
        impl Ext4Fs {
            pub fn read_file(&self, _path: &str) -> Result<&'static [u8], ()> {
                Ok(&[])
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ fat32.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Fat32Fs {
            
        }
        
        impl Fat32Fs {
            pub fn read_file(&self, _path: &str) -> Result<&'static [u8], ()> {
                Ok(&[])
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ iso9660.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Iso9660Fs {
            
        }
        
        impl Iso9660Fs {
            pub fn new(_data: &[u8]) -> Self {
                Iso9660Fs {}
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod fat32;
        pub mod ext4;
        pub mod iso9660;
        pub mod apfs;
        pub mod btrfs;
        pub mod pfs;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ pfs.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Pfs {
            
        }
        
        impl Pfs {
            pub fn new() -> Self {
                Pfs {}
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ lang
        ğŸ“„ en.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub const BOOT_MSG: &str = "Bootloader Initialized";
        pub const ERROR: &str = "Error";        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod en;
        pub mod ru;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ ru.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub const BOOT_MSG: &str = "Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ñ‡Ğ¸Ğº Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½";
        pub const ERROR: &str = "ĞÑˆĞ¸Ğ±ĞºĞ°";        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“„ main.rs
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #![no_std]
    #![no_main]
    #![feature(alloc_error_handler)]
    
    mod alloc;
    mod features;
    
    use core::fmt::Write;
    use core::ptr;
    // Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ Ğ´Ğ»Ñ x86_64
    use plum_formats::plam::{PlamHeader, PLAM_MAGIC, PLAM_CPU_X86_64, PLAM_CPU_ARM64};
    use plum_hal::block::{BlockError, init_block_devices, get_block_device_manager, BlockDevice};
    use spin::Mutex;
    extern crate alloc as rust_alloc;
    use alloc::early_alloc::STACK_ALLOC;
    use core::alloc::{GlobalAlloc, Layout};
    
    // === Ğ¢Ñ€ĞµĞ¹Ñ‚ UART (Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾!) ===
    use plum_hal::Uart;
    
    // === ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ¾-Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğ¹ UART ===
    #[cfg(target_arch = "aarch64")]
    use plum_hal::uart::pl011::Pl011Uart as DefaultUart;
    
    #[cfg(target_arch = "x86_64")]
    use plum_hal::uart::ns16550::Ns16550Uart as DefaultUart;
    
    #[cfg(target_arch = "riscv64")]
    use plum_hal::uart::uart16550::Uart16550 as DefaultUart;
    
    // === ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯ UART ===
    #[cfg(target_arch = "aarch64")]
    const UART_BASE: usize = 0x0900_0000;
    
    #[cfg(target_arch = "x86_64")]
    const UART_BASE: usize = 0x3F8;
    
    #[cfg(target_arch = "riscv64")]
    const UART_BASE: usize = 0x1000_0000;
    
    // === Ğ“Ğ›ĞĞ‘ĞĞ›Ğ¬ĞĞ«Ğ™ ĞĞ›Ğ›ĞĞšĞĞ¢ĞĞ  ===
    struct EarlyAllocator;
    unsafe impl GlobalAlloc for EarlyAllocator {
        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
            STACK_ALLOC
                .lock()
                .allocate(layout.size(), layout.align())
                .unwrap_or(ptr::null_mut())
        }
        unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}
    }
    #[global_allocator]
    static EARLY_ALLOC: EarlyAllocator = EarlyAllocator;
    
    // === UART (Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· Once) ===
    use spin::Once;
    static UART: Once<Mutex<DefaultUart>> = Once::new();
    
    pub struct ConsoleWriter;
    impl Write for ConsoleWriter {
        fn write_str(&mut self, s: &str) -> core::fmt::Result {
            let uart = UART.get().expect("UART not initialized").lock();
            for b in s.bytes() {
                let _ = uart.putc(b); // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ putc, Ğ° Ğ½Ğµ puts
            }
            Ok(())
        }
    }
    
    // === PANIC & ALLOC ERROR ===
    #[panic_handler]
    fn panic(info: &core::panic::PanicInfo) -> ! {
        let mut w = ConsoleWriter;
        let _ = write!(&mut w, "PANIC: {}\n", info);
        loop {}
    }
    
    #[alloc_error_handler]
    fn alloc_error_handler(layout: Layout) -> ! {
        let mut w = ConsoleWriter;
        let _ = write!(&mut w, "Allocation error: {:?}\n", layout);
        loop {}
    }
    
    fn init_uart() {
        UART.call_once(|| {
            let mut uart = unsafe { DefaultUart::new(UART_BASE) };
            let _ = uart.init(); // Ğ¢ĞµĞ¿ĞµÑ€ÑŒ init() Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½ Ğ±Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€Ñ use plum_hal::Uart;
            Mutex::new(uart)
        });
    }
    
    // === Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ Ğ¯Ğ”Ğ Ğ ===
    pub fn load_kernel_from_disk() -> Result<usize, BlockError> {
        let mut w = ConsoleWriter;
        let _ = write!(&mut w, "bootloader: initializing block devices...\n");
        init_block_devices()?;
        let mut mgr = get_block_device_manager();
        let dev = mgr.get_device(0).ok_or(BlockError::DeviceError)?;
        let _ = write!(&mut w, "bootloader: reading kernel from LBA\n");
    
        const KERNEL_SIZE: usize = 32 * 1024 * 1024;
        let mut buffer = rust_alloc::vec![0u8; KERNEL_SIZE];
        dev.read_blocks(2048 / 512, &mut buffer)?; // LBA 4 = 2048 bytes
    
        if buffer.len() < core::mem::size_of::<PlamHeader>() {
            return Err(BlockError::InvalidParameter);
        }
    
        let header = unsafe { &*(buffer.as_ptr() as *const PlamHeader) };
        if header.magic != PLAM_MAGIC {
            return Err(BlockError::InvalidParameter);
        }
    
        // === ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° CPU ID ===
        #[cfg(target_arch = "x86_64")]
        if header.cpu_id != PLAM_CPU_X86_64 {
            return Err(BlockError::InvalidParameter);
        }
        #[cfg(target_arch = "aarch64")]
        if header.cpu_id != PLAM_CPU_ARM64 {
            return Err(BlockError::InvalidParameter);
        }
        #[cfg(target_arch = "riscv64")]
        if header.cpu_id != PLAM_CPU_RISCV64 {
            return Err(BlockError::InvalidParameter);
        }
    
        let image_base = header.image_base as usize;
        let entry_offset = header.entry_offset as usize;
        let entry = image_base + entry_offset;
    
        unsafe {
            ptr::copy_nonoverlapping(buffer.as_ptr(), image_base as *mut u8, buffer.len());
        }
    
        let _ = write!(&mut w, "bootloader: PLAM OK, loaded to {:#x}, entry {:#x}\n", image_base, entry);
        Ok(entry)
    }
    
    // === Ğ¢ĞĞ§ĞšĞ Ğ’Ğ¥ĞĞ”Ğ ===
    #[no_mangle]
    pub extern "C" fn bootloader_main() -> ! {
        init_uart();
    
        let mut w = ConsoleWriter;
        #[cfg(target_arch = "x86_64")]
        let _ = write!(&mut w, "x86_64 UEFI Bootloader Initialized!\n");
        #[cfg(target_arch = "aarch64")]
        let _ = write!(&mut w, "AArch64 Baremetal Bootloader Initialized!\n");
        #[cfg(target_arch = "riscv64")]
        let _ = write!(&mut w, "RISC-V64 Baremetal Bootloader Initialized!\n");
    
        match load_kernel_from_disk() {
            Ok(entry) => {
                let _ = write!(&mut w, "bootloader: jumping to kernel at {:#x}\n", entry);
                let entry_fn: extern "C" fn() -> ! = unsafe { core::mem::transmute(entry) };
                entry_fn();
            }
            Err(e) => {
                let _ = write!(&mut w, "bootloader: failed to load kernel: {:?}\n", e);
                loop {}
            }
        }
    }    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ secure
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod sha256;
        pub mod rsa;
        pub mod sb;
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ rsa.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub fn rsa_sign(_data: &[u8]) -> &'static [u8] {
            &[]
        }
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ sb.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub fn secure_boot_verify(_signature: &[u8]) -> bool {
            true
        }
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ sha256.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        use sha2::{Sha256, Digest};
        
        pub fn sha256(data: &[u8]) -> [u8; 32] {
            let mut hasher = Sha256::new();
            hasher.update(data);
            hasher.finalize().into()
        }
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ security
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod hash;
        pub mod signature;
        pub mod validator;
        
        use crate::formats::plam::PlamHeader;
        
        pub struct SecurityContext {
            pub secure_boot_enabled: bool,
            pub allowed_keys: Vec<[u8; 32]>,
        }
        
        impl SecurityContext {
            pub fn verify_plam(&self, header: &PlamHeader, data: &[u8]) -> Result<(), SecurityError> {
                
                if header.magic != 0x504C414D {
                    return Err(SecurityError::InvalidFormat);
                }
                
                
                if !hash::verify_crc32(header, data) {
                    return Err(SecurityError::ChecksumMismatch);
                }
                
                
                if self.secure_boot_enabled {
                    signature::verify_signature(header, data, &self.allowed_keys)?;
                }
                
                
                validator::validate_compatibility(header)?;
                
                Ok(())
            }
        }
        
        #[derive(Debug)]
        pub enum SecurityError {
            InvalidFormat,
            ChecksumMismatch,
            InvalidSignature,
            IncompatibleVersion,
            UnsupportedArchitecture,
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ time
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod rtc;
        pub mod ntp;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ ntp.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub fn get_ntp_time() -> u64 {
            
            0
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“„ rtc.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub struct Rtc {
            
        }
        
        impl Rtc {
            pub fn get_time(&self) -> u64 {
                0
            }
        }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ ui
        ğŸ“ gfx
            ğŸ“„ fb.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub struct Framebuffer {
                base: *mut u8,
                width: u32,
                height: u32,
                stride: u32,
                bpp: u8,
            }
            
            impl Framebuffer {
                pub fn clear(&mut self, color: u32) { ... }
                pub fn draw_bitmap(&mut self, x: u32, y: u32, bmp: &Bitmap) { ... }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub mod fb;
            pub mod qr;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ qr.rs
            [binary file skipped]
        ğŸ“„ mod.rs
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        pub mod gfx;
        pub mod tui;        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ tui
            ğŸ“„ menu.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub struct BootMenu {
                items: [&'static str; 4],
                selected: usize,
                theme: Theme,
            }
            
            impl BootMenu {
                pub fn draw(&self) {
                    
                    
                    
                    
                }
            
                pub fn handle_key(&mut self, key: u8) {
                    match key {
                        b'j' | 0x51 => self.selected = (self.selected + 1) % self.items.len(), 
                        b'k' | 0x50 => self.selected = self.selected.wrapping_sub(1),          
                        b'\r' => self.boot_selected(),
                        _ => {}
                    }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ mod.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub mod menu;
            pub mod theme;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ theme.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub struct Theme {
                color: u32,
            }
            
            impl Theme {
                pub fn new() -> Self {
                    Theme { color: 0xffffff }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
