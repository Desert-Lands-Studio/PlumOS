ğŸ“ headers
    ğŸ“„ plam_header.h
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #pragma once
    #include <stdint.h>
    
    /*====================================================================*
     *  PLAM_FORMAT â€” Portable Linking And Modules (v3.0.3)
     *  --------------------------------------------------
     *  On-disk format for PlumOS: kernels, drivers, apps, resources.
     *  All structures are 1-byte packed for cross-platform compatibility.
     *  CPU feature flags are architecture-specific to avoid collisions.
     *====================================================================*/
    
    #pragma pack(push, 1)   /* 1-byte packing */
    
    /*-------------------------------- Magic numbers -------------------------*/
    #define PLAM_MAGIC      0x504C414Du  /* "PLAM" */
    #define PLAM_FAT_MAGIC  0x504C4D46u  /* "PLMF" */
    #define PLAM_RES_MAGIC  0x504C4D52u  /* "PLMR" */
    
    /*-------------------------------- Versioning ---------------------------*/
    #define PLAM_VERSION_MAJOR 3
    #define PLAM_VERSION_MINOR 0
    #define PLAM_VERSION_PATCH 3
    
    /*-------------------------------- Generic helpers -----------------------*/
    typedef struct { uint64_t off, sz; } plam_rva_t;   /* Offset + size */
    
    /*-------------------------------- CPU architecture ----------------------*/
    typedef enum : uint16_t {
        PLAM_CPU_NONE    = 0x0000,
        PLAM_CPU_X86_64  = 0x8664,      
        PLAM_CPU_ARM64   = 0xAA64,      
        PLAM_CPU_RISCV64 = 0x00F3,      
        PLAM_CPU_PRUM64  = 0x7072,
        PLAM_CPU_UNKNOWN = 0xFFFF
    } plam_cpu_t;
    
    /* CPU sub-features (bit-mask per arch; no cross-arch collisions) */
    typedef enum : uint64_t {
        
        PLAM_CPU_X86_64_SSE      = 1ULL <<  0,
        PLAM_CPU_X86_64_SSE2     = 1ULL <<  1,
        PLAM_CPU_X86_64_SSE3     = 1ULL <<  2,
        PLAM_CPU_X86_64_SSSE3    = 1ULL <<  3,
        PLAM_CPU_X86_64_SSE4_1   = 1ULL <<  4,
        PLAM_CPU_X86_64_SSE4_2   = 1ULL <<  5,
        PLAM_CPU_X86_64_AVX      = 1ULL <<  6,
        PLAM_CPU_X86_64_F16C     = 1ULL <<  7,
        PLAM_CPU_X86_64_FMA      = 1ULL <<  8,
        PLAM_CPU_X86_64_AVX2     = 1ULL <<  9,
        PLAM_CPU_X86_64_BMI1     = 1ULL << 10,
        PLAM_CPU_X86_64_BMI2     = 1ULL << 11,
        PLAM_CPU_X86_64_ADX      = 1ULL << 12,
        PLAM_CPU_X86_64_RDSEED   = 1ULL << 13,
        PLAM_CPU_X86_64_SHA      = 1ULL << 14,
        PLAM_CPU_X86_64_AVX512F  = 1ULL << 15,
        PLAM_CPU_X86_64_AVX512DQ = 1ULL << 16,
        PLAM_CPU_X86_64_AVX512IFMA = 1ULL << 17,
        PLAM_CPU_X86_64_AVX512PF = 1ULL << 18,
        PLAM_CPU_X86_64_AVX512ER = 1ULL << 19,
        PLAM_CPU_X86_64_AVX512CD = 1ULL << 20,
        PLAM_CPU_X86_64_AVX512BW = 1ULL << 21,
        PLAM_CPU_X86_64_AVX512VL = 1ULL << 22,
        PLAM_CPU_X86_64_AVX512VBMI = 1ULL << 23,
        PLAM_CPU_X86_64_AVX512VNNI = 1ULL << 24,
        PLAM_CPU_X86_64_VAES     = 1ULL << 25,
        PLAM_CPU_X86_64_VPCLMULQDQ = 1ULL << 26,
        PLAM_CPU_X86_64_GFNI     = 1ULL << 27,
        PLAM_CPU_X86_64_SHSTK    = 1ULL << 28,
        PLAM_CPU_X86_64_PCONFIG  = 1ULL << 29,
        PLAM_CPU_X86_64_LAM      = 1ULL << 30,
        PLAM_CPU_X86_64_LBR      = 1ULL << 31,
    
        
        PLAM_CPU_ARM64_NEON      = 1ULL << 32,
        PLAM_CPU_ARM64_SVE       = 1ULL << 33,
        PLAM_CPU_ARM64_SVE2      = 1ULL << 34,
        PLAM_CPU_ARM64_SVE_BF16  = 1ULL << 35,
        PLAM_CPU_ARM64_SVE_I8MM  = 1ULL << 36,
        PLAM_CPU_ARM64_LSE       = 1ULL << 37,
        PLAM_CPU_ARM64_CRC32     = 1ULL << 38,
        PLAM_CPU_ARM64_SHA1_SHA2 = 1ULL << 39,
        PLAM_CPU_ARM64_SHA3      = 1ULL << 40,
        PLAM_CPU_ARM64_SM4       = 1ULL << 41,
        PLAM_CPU_ARM64_DIT       = 1ULL << 42,
        PLAM_CPU_ARM64_PAUTH     = 1ULL << 43,
        PLAM_CPU_ARM64_MTE       = 1ULL << 44,
        PLAM_CPU_ARM64_SME       = 1ULL << 45,
        PLAM_CPU_ARM64_VHE       = 1ULL << 46,
        PLAM_CPU_ARM64_SB        = 1ULL << 47,
    
        
        PLAM_CPU_RISCV_VECTOR    = 1ULL << 48,
        PLAM_CPU_RISCV_ZFH       = 1ULL << 49,
        PLAM_CPU_RISCV_ZFBFMIN   = 1ULL << 50,
        PLAM_CPU_RISCV_ZB        = 1ULL << 51,
        PLAM_CPU_RISCV_ZBB       = 1ULL << 52,
        PLAM_CPU_RISCV_ZK        = 1ULL << 53,
        PLAM_CPU_RISCV_ZVKB      = 1ULL << 54,
        PLAM_CPU_RISCV_ZVBC      = 1ULL << 55,
        PLAM_CPU_RISCV_ZAAMO     = 1ULL << 56,
        PLAM_CPU_RISCV_SVADU     = 1ULL << 57,
        PLAM_CPU_RISCV_SV57      = 1ULL << 58,
        PLAM_CPU_RISCV_H         = 1ULL << 59,
        PLAM_CPU_RISCV_SQOSID    = 1ULL << 60,
        PLAM_CPU_RISCV_SVINVAL   = 1ULL << 61,
        PLAM_CPU_RISCV_ZVAMACC   = 1ULL << 62,
        PLAM_CPU_RISCV_ZVMMUL    = 1ULL << 63,
    
    } plam_cpu_subtype_t;
    
    /*-------------------------------- File types ----------------------------*/
    typedef enum : uint16_t {
        PLAM_FT_NONE     = 0x00,
        PLAM_FT_KERNEL   = 0x01,
        PLAM_FT_DRIVER   = 0x02,
        PLAM_FT_SHARED   = 0x03,
        PLAM_FT_APP      = 0x04,
        PLAM_FT_MODULE   = 0x05,
        PLAM_FT_BOOT     = 0x06,
        PLAM_FT_PLUGIN   = 0x07,
        PLAM_FT_OBJECT   = 0x08,
        PLAM_FT_FIRMWARE = 0x09,
        PLAM_FT_RESOURCE_ONLY = 0x0A
    } plam_file_type_t;
    
    /*-------------------------------- Program Header Types ------------------*/
    #define PLAM_PT_NULL         0
    #define PLAM_PT_LOAD         1
    #define PLAM_PT_DYNAMIC      2
    #define PLAM_PT_INTERP       3
    #define PLAM_PT_NOTE         4
    #define PLAM_PT_SHLIB        5
    #define PLAM_PT_PHDR         6
    #define PLAM_PT_TLS          7
    #define PLAM_PT_LOOS         0x60000000
    #define PLAM_PT_HIOS         0x6FFFFFFF
    #define PLAM_PT_LOPROC       0x70000000
    #define PLAM_PT_HIPROC       0x7FFFFFFF
    
    /* Program Header Flags */
    #define PLAM_PF_X            (1 << 0)  /* Execute */
    #define PLAM_PF_W            (1 << 1)  /* Write */
    #define PLAM_PF_R            (1 << 2)  /* Read */
    
    /*-------------------------------- Security ------------------------------*/
    #define PLAM_SIG_ED25519  1
    #define PLAM_SIG_ECDSA    2
    #define PLAM_SIG_FALCON   5
    #define PLAM_SIG_SPHINCS  4
    
    #define PLAM_HASH_SHA256   1
    #define PLAM_HASH_SHA384   2
    #define PLAM_HASH_SHA512   3
    #define PLAM_HASH_BLAKE3   4
    #define PLAM_HASH_SHA3_512 5
    
    typedef struct {
        uint8_t  sig_type;
        uint8_t  hash_alg;
        uint8_t  sig_len;
        uint16_t key_rev;
        uint8_t  key_revocation;
        uint16_t cert_count;
        uint64_t timestamp;
        uint8_t  sig_type_v2;
        uint8_t  cert_chain_off;
        uint16_t attestation_flags;
        uint64_t tpm_quote;
        uint64_t sig_data_off;
        uint64_t custom_oid_off;  /* NEW: Offset to custom OID string (for extensible algos) */
        uint8_t  reserved[6 - sizeof(uint64_t)];  /* Adjusted reserved */
    } plam_sig_header_t;
    
    /*-------------------------------- Resources -----------------------------*/
    typedef enum : uint16_t {
        PLAM_RES_ICON        = 0x0100,
        PLAM_RES_VERSION     = 0x0200,
        PLAM_RES_DEPENDENCY  = 0x0300,
        PLAM_RES_STRING      = 0x0400,
        PLAM_RES_UI          = 0x0500,
        PLAM_RES_PERMISSIONS = 0x0600,
        PLAM_RES_MANIFEST    = 0x0700,
        PLAM_RES_LOCALIZATION= 0x0800,
        PLAM_RES_CONFIG      = 0x0900,
        PLAM_RES_UI_LAYOUT   = 0x0A00,
        PLAM_RES_DEVICE_TREE = 0x0B00,
        PLAM_RES_VM_CONFIG   = 0x0C00,
        PLAM_RES_SUBSYS_MANIFEST = 0x0D00,
        PLAM_RES_VENDOR      = 0xF000
    } plam_res_type_t;
    
    typedef struct {
        uint32_t width;
        uint32_t height;
        uint8_t  format;
        uint8_t  mip_levels;
        uint16_t flags;
    } plam_icon_info_t;
    
    typedef struct {
        uint64_t cap_flags[4];
    } plam_permissions_t;
    
    /*-------------------------------- Section types -------------------------*/
    #define PLAM_SHT_NULL        0
    #define PLAM_SHT_PROGBITS    1
    #define PLAM_SHT_SYMTAB      2
    #define PLAM_SHT_STRTAB      3
    #define PLAM_SHT_RELA        4
    #define PLAM_SHT_HASH        5
    #define PLAM_SHT_DYNAMIC     6
    #define PLAM_SHT_NOTE        7
    
    #define PLAM_SHT_ACCEL_CODE  0x80000001
    #define PLAM_SHT_ACCEL_DATA  0x80000002
    #define PLAM_SHT_ACCEL_CFG   0x80000003
    #define PLAM_SHT_WASM_CODE   0x80000010
    #define PLAM_SHT_METADATA    0x800000FF
    
    /*-------------------------------- Section table -------------------------*/
    #define PLAM_SEC_READ     (1u << 0)
    #define PLAM_SEC_WRITE    (1u << 1)
    #define PLAM_SEC_EXEC     (1u << 2)
    #define PLAM_SEC_NOBITS   (1u << 3)
    #define PLAM_SEC_RELOC    (1u << 4)
    #define PLAM_SEC_DEBUG    (1u << 5)
    #define PLAM_SEC_ENCRYPTED (1u << 6)
    #define PLAM_SEC_PURGABLE  (1u << 7)
    
    typedef struct {
        uint64_t name_off;
        uint32_t type;
        uint32_t flags;
        uint64_t addr;
        uint64_t offset;
        uint64_t size;
        uint64_t entsize;
        uint64_t align;
        uint32_t section_prot;
        uint32_t comp_alg;
        uint32_t comp_level;
        uint32_t entropy;
        uint64_t hash_offset;
    } plam_section_t;
    
    /*-------------------------------- Relocations ---------------------------*/
    #define PLAM_REL_NONE   0
    #define PLAM_REL_64     1
    #define PLAM_REL_ARM64  2
    #define PLAM_REL_RISCV  3
    #define PLAM_REL_ACCEL  4
    
    typedef struct {
        uint64_t offset;
        uint32_t type;
        uint32_t sym_idx;
        int64_t  addend;
        uint32_t accelerator;
        uint32_t reserved;
    } plam_reloc_t;
    
    /*-------------------------------- Symbols --------------------------------*/
    #define PLAM_SYM_NOTYPE  0
    #define PLAM_SYM_FUNC    1
    #define PLAM_SYM_OBJECT  2
    #define PLAM_SYM_SECTION 3
    #define PLAM_SYM_FILE    4
    #define PLAM_SYM_COMMON  5
    #define PLAM_SYM_TLS     6
    #define PLAM_SYM_IFUNC   7
    #define PLAM_SYM_ACCEL   8
    
    #define PLAM_SYM_LOCAL   0
    #define PLAM_SYM_GLOBAL  1
    #define PLAM_SYM_WEAK    2
    
    typedef struct {
        uint64_t name_off;
        uint64_t value;
        uint64_t size;
        uint8_t  type;
        uint8_t  bind;
        uint16_t section_idx;
        uint32_t version;
        uint32_t flags;
        uint32_t accelerator;
        uint32_t reserved;
    } plam_symbol_t;
    
    /*-------------------------------- Unwind --------------------------------*/
    typedef struct {
        uint64_t begin_addr;
        uint64_t end_addr;
        uint64_t unwind_info_off;
        uint32_t flags;
        uint32_t personality_idx; /* Personality function symbol index */
        uint32_t accelerator;    /* Accelerator-specific unwind */
        uint32_t reserved;
    } plam_unwind_entry_t;
    
    /*-------------------------------- Dynamic linking -----------------------*/
    #define PLAM_DEP_WEAK       (1u << 0)
    #define PLAM_DEP_OPTIONAL   (1u << 1)
    #define PLAM_DEP_REQUIRED   (1u << 2)
    #define PLAM_DEP_REEXPORT   (1u << 3)
    
    typedef struct {
        uint64_t name_off;
        uint64_t version_min;  /* Minimum required version */
        uint64_t version_max;  /* Maximum compatible version */
        uint8_t  uuid[16];     /* Library UUID */
        uint32_t flags;        /* PLAM_DEP_* */
        uint32_t compat_flags; /* Compatibility flags */
    } plam_dependency_entry_t;
    
    typedef struct {
        uint64_t name_off;
        uint64_t module_uuid[2]; /* Module identifier */
        uint64_t version;        /* Required version */
        uint32_t flags;
        uint32_t accelerator;    /* For accelerator-specific symbols */
    } plam_import_entry_t;
    
    /*-------------------------------- Compression ---------------------------*/
    #define PLAM_COMP_NONE      0
    #define PLAM_COMP_LZ4       1
    #define PLAM_COMP_ZSTD      2
    #define PLAM_COMP_LZMA      3
    #define PLAM_COMP_BROTLI    4
    #define PLAM_COMP_ZLIB      5
    
    /* Compression levels */
    #define PLAM_COMP_LEVEL_DEFAULT  0
    #define PLAM_COMP_LEVEL_MIN      1
    #define PLAM_COMP_LEVEL_MAX      22
    
    /*-------------------------------- Global flags --------------------------*/
    #define PLAM_F_PIE            (1u << 0)
    #define PLAM_F_ASLR           (1u << 1)
    #define PLAM_F_NX_STACK       (1u << 2)
    #define PLAM_F_NX_HEAP        (1u << 3)
    #define PLAM_F_GUARD_CF       (1u << 4)
    #define PLAM_F_SEH_SAFE       (1u << 5)
    #define PLAM_F_ISOLATED_MEM   (1u << 6)
    #define PLAM_F_DEBUG_STRIPPED (1u << 7)
    #define PLAM_F_NO_REEXPORTS   (1u << 8)
    #define PLAM_F_HW_ACCEL       (1u << 9)
    #define PLAM_F_HOT_PATCHABLE  (1u << 10)
    #define PLAM_F_RELOCS_STRIPPED (1u << 11)
    #define PLAM_F_SMART_STACK    (1u << 12)
    #define PLAM_F_LIVEPATCH      (1u << 13)
    #define PLAM_F_MEMORY_COMPRESS (1u << 14)
    #define PLAM_F_SECURE_LAUNCH   (1u << 15)
    #define PLAM_F_CFI_ENABLED    (1u << 16)  /* Control Flow Integrity */
    #define PLAM_F_SHADOW_STACK   (1u << 17)  /* Shadow Stack (CET) */
    #define PLAM_F_MEM_TAGGING    (1u << 18)  /* ARM MTE / RISC-V J-extension */
    #define PLAM_F_SEALED_HEAP    (1u << 19)  /* Sealed heap */
    #define PLAM_F_PAC_ENABLED    (1u << 20)  /* ARM Pointer Authentication */
    #define PLAM_F_PREFETCH_READY (1u << 21)  /* Prefetch optimized */
    #define PLAM_F_LAZY_BINDING   (1u << 22)  /* Lazy binding */
    #define PLAM_F_COMPRESSED_FILE   (1u << 23)
    #define PLAM_F_ENCRYPTED_FILE    (1u << 24)
    
    #define PLAM_RELRO_NONE 0
    #define PLAM_RELRO_PART 1
    #define PLAM_RELRO_FULL 2
    
    /*-------------------------------- Subsystems ----------------------------*/
    typedef enum : uint16_t {
        PLAM_SUBSYS_UNKNOWN       = 0,    /* Unknown subsystem */
        PLAM_SUBSYS_NATIVE_KERNEL = 1,    /* Native kernel components */
        PLAM_SUBSYS_DRIVER        = 2,    /* Device drivers */
        PLAM_SUBSYS_SYSTEM_SERV   = 3,    /* System services (daemons) */
        PLAM_SUBSYS_CONSOLE_APP   = 4,    /* Console applications */
        PLAM_SUBSYS_GUI_APP       = 5,    /* GUI applications */
        PLAM_SUBSYS_HYPERVISOR    = 6,    /* Hypervisor/virtualization */
        PLAM_SUBSYS_FIRMWARE      = 7,    /* Embedded firmware */
        PLAM_SUBSYS_SECURITY      = 8,    /* Security components */
        PLAM_SUBSYS_CONTAINER     = 9,    /* Containers */
        PLAM_SUBSYS_RUNTIME       = 10,   /* Execution environments (WASM, JVM) */
        PLAM_SUBSYS_RECOVERY      = 11,   /* Recovery mode */
        PLAM_SUBSYS_BOOTLOADER    = 12,   /* Bootloaders */
        PLAM_SUBSYS_WASM          = 13, 
        PLAM_SUBSYS_VENDOR_START  = 0x8000 /* Vendor-specific range start */
    } plam_subsystem_t;
    
    /* Subsystem flags */
    #define PLAM_SUBSYS_F_REQUIRES_NETWORK  (1 << 0)
    #define PLAM_SUBSYS_F_REQUIRES_STORAGE  (1 << 1)
    #define PLAM_SUBSYS_F_REQUIRES_GPU      (1 << 2)
    #define PLAM_SUBSYS_F_GUI_WINDOWED      (1 << 8)  /* Windowed mode support */
    #define PLAM_SUBSYS_F_GUI_HIGH_DPI      (1 << 9)  /* HiDPI support */
    #define PLAM_SUBSYS_F_DRIVER_HOTPLUG    (1 << 10) /* Hotplug support */
    #define PLAM_SUBSYS_F_ISOLATED_EXEC     (1 << 11) /* Isolated execution */
    
    /* NEW: Memory region flags for plam_mem_region_t */
    #define PLAM_MEM_DMA         (1u << 0)  /* DMA-accessible */
    #define PLAM_MEM_SECURE      (1u << 1)  /* Secure enclave */
    #define PLAM_MEM_SHARED      (1u << 2)  /* Shared memory */
    #define PLAM_MEM_NONCACHED   (1u << 3)  /* Non-cached */
    
    /* NEW: Memory region structure (array via mem_regions RVA) */
    typedef struct {
        uint64_t base;    /* Base address (preferred or required) */
        uint64_t size;    /* Size of region */
        uint32_t flags;   /* PLAM_MEM_* */
        uint32_t reserved;
    } plam_mem_region_t;
    
    /* Subsystem parameters */
    typedef union {
        struct {  /* GUI applications */
            uint32_t min_width;
            uint32_t min_height;
            uint8_t  color_depth;
            uint8_t  dpi_aware;
            uint16_t gfx_requirements;
        } gui;
        
        struct {  /* Drivers */
            uint16_t device_class;
            uint16_t protocol_ver;
            uint32_t io_privileges;
        } driver;
        
        struct {  /* Containers */
            uint8_t  isolation_level;
            uint8_t  ns_flags;
            uint16_t cap_count;
        } container;
        
        struct {  /* Hypervisors */
            uint32_t vm_extensions;
            uint16_t max_vcpus;
            uint16_t max_ram_slots;
        } hypervisor;
    
         struct {  /* WASM */
            uint32_t wasm_memory_min;   /* ĞœĞ¸Ğ½. ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ† (64 KiB) */
            uint32_t wasm_memory_max;
            uint32_t stack_size;
            uint8_t  enable_simd;
            uint8_t  enable_threads;
            uint16_t reserved;
        } wasm;
        
        uint8_t raw[24];  /* Raw data for custom subsystems */
        uint64_t ext_off; /* NEW: Offset to TLV extensions for dynamic fields */
    } plam_subsystem_params_t;
    
    /* Execution environments */
    #define PLAM_SUBSYS_ENV_KERNEL_SPACE  0x01
    #define PLAM_SUBSYS_ENV_USER_SPACE    0x02
    #define PLAM_SUBSYS_ENV_SECURE_ENC    0x04
    
    /* Isolation levels */
    #define PLAM_ISOL_NONE        0
    #define PLAM_ISOL_USER        1
    #define PLAM_ISOL_SANDBOX     2
    #define PLAM_ISOL_CONTAINER   3
    #define PLAM_ISOL_VM          4
    
    /*-------------------------------- Directories table ---------------------*/
    typedef struct {
        plam_rva_t security;         /* Digital signatures */
        plam_rva_t loadcfg;          /* Load configuration */
        plam_rva_t tls;              /* Thread-Local Storage */
        plam_rva_t cfg;              /* Configuration data */
        plam_rva_t exceptions;       /* Exception handling */
        plam_rva_t basereloc;        /* Base relocation table */
        plam_rva_t import_table;     /* Import table */
        plam_rva_t export_table;     /* Export table */
        plam_rva_t got;              /* Global Offset Table */
        plam_rva_t plt;              /* Procedure Linkage Table */
        plam_rva_t subsystem_validator; /* Subsystem validator */
        uint64_t   fat_off;          /* FAT multi-arch offset */
        uint32_t   fat_cnt;          /* FAT entry count */
        uint32_t   fat_flags;        /* FAT flags */
    } plam_directories_t;
    
    /*-------------------------------- Program headers ---------------------*/
    typedef struct {
        uint32_t type;
        uint32_t flags;
        uint64_t offset;
        uint64_t vaddr;
        uint64_t paddr;
        uint64_t filesz;
        uint64_t memsz;
        uint64_t align;
        uint8_t  accelerator;
        uint8_t  mem_space;
        uint16_t acc_flags;
        uint32_t acc_priv;
        uint32_t reserved_ph;
    } plam_phdr_t;
    
    /*-------------------------------- FAT arch entry ------------------------*/
    #define PLAM_FAT_HAS_PHDR   (1u << 0)
    #define PLAM_FAT_COMPRESSED (1u << 1)
    
    #define PLAM_ACCEL_NONE  0x00
    #define PLAM_ACCEL_GPU   0x01
    #define PLAM_ACCEL_TPU   0x02
    #define PLAM_ACCEL_FPGA  0x03
    #define PLAM_ACCEL_NPU   0x04
    
    typedef struct {
        uint16_t cpu_id;
        uint16_t cpu_sub;
        uint16_t abi_ver;
        uint16_t align_log2;
        uint64_t offset;
        uint64_t size;
        uint32_t flags;
        uint8_t  accelerator;
        uint8_t  mem_space;
        uint16_t vendor_id;
        uint64_t ph_off;
        uint16_t ph_count;
        uint16_t ph_entsize;
    } plam_fatarch_t;
    /*-------------------------------- Debug ------------------------*/
    #define PLAM_DEBUG_DWARF  1
    #define PLAM_DEBUG_PDB    2
    #define PLAM_DEBUG_CUSTOM 3
    
    typedef struct {
        plam_rva_t debug;
        uint16_t debug_type;
        uint16_t debug_version;
        uint32_t debug_size;
    } plam_debug_info_t;
    
    /*-------------------------------- Manifest ------------------------------*/
    typedef struct {
        uint64_t min_os_ver;     /* Minimum OS version */
        uint64_t target_os_ver;  /* Target OS version */
        uint32_t feature_flags;  /* Required CPU features */
        uint32_t security_flags; /* Security requirements */
    } plam_manifest_req_t;
    
    /*-------------------------------- Build info --------------------------*/
    typedef struct {
        uint64_t build_timestamp;
        uint64_t source_hash;
        uint32_t toolchain_ver;
        uint32_t optimization;
        char     builder_name[32];
        uint32_t build_flags;
        uint32_t reserved;
    } plam_build_info_t;
    
    /*-------------------------------- Main header ---------------------------*/
    typedef struct {
        uint32_t magic;
        uint16_t version;
        uint64_t flags;
        uint64_t file_size;
        uint32_t hdr_crc32;
        uint32_t file_crc32;
    
        uint32_t format_version;
        uint32_t content_version;
    
        uint64_t image_base;
        uint64_t entry_offset;
        uint64_t stack_reserve;
        uint64_t stack_commit;
        uint64_t heap_reserve;
        uint64_t heap_commit;
    
        uint16_t cpu_id;
        uint16_t cpu_sub;
        uint32_t abi_version;
        uint64_t cpu_features;
        uint32_t os_abi;
        uint32_t os_version_min;
        uint32_t os_version_sdk;
    
        plam_rva_t str_table;
        plam_rva_t sym_table;
        uint64_t section_table_off;
        uint32_t section_count;
        uint64_t reloc_table_off;
        uint32_t reloc_count;
    
        uint64_t ph_off;
        uint16_t ph_count;
        uint16_t ph_entry_size;
    
        plam_rva_t resources;
        plam_debug_info_t debug;
    
        uint8_t uuid[16];
        uint8_t build_hash[48];
        uint64_t timestamp;
        uint16_t crypto_mode;
        uint16_t hash_type;
        uint16_t sig_scheme;
        uint8_t  relro_level;
        uint8_t  file_compression;
    
        plam_rva_t manifest;
        uint32_t deps_count;
        uint32_t res_count;
    
        uint32_t lang_mask;
        uint16_t tool_major;
        uint16_t tool_minor;
        uint16_t tool_patch;
        uint16_t stdlib_ver;
        uint8_t  comp_model;
        uint8_t  lto_pgo_flags;
        uint8_t  opt_level;
        uint8_t  debug_level;
    
        plam_directories_t dirs;
    
        uint64_t control_flow_start;
        uint64_t control_flow_size;
        uint32_t hotpatch_offset;
        uint32_t hotpatch_count;
    
        uint16_t subsystem_type;
        uint16_t subsystem_version;
        plam_subsystem_params_t subsystem_params;
        uint32_t subsystem_flags;
    
        uint16_t sec_flags;
        uint8_t  sanitizer_level;
        uint8_t  crypt_alg;
        uint8_t  branch_prot;
        uint8_t  prefetch_hint;
        uint16_t cache_align;
    
        uint8_t  isolation_level;
        uint8_t  namespace_flags;
        uint16_t container_features;
    
        uint64_t metadata_size;
        plam_rva_t build_info;
        plam_rva_t api_constraints;
    
        uint64_t code_size;
        uint64_t init_data_size;
        uint64_t uninit_data_size;
    
        uint64_t ext_hdr_off;
    
        plam_rva_t mem_regions;  /* NEW: RVA to array of plam_mem_region_t for custom memory areas */
    
        uint8_t endian;          /* NEW: 0 = Little-Endian, 1 = Big-Endian */
        uint8_t  reserved[63];  /* Adjusted reserved (was 64) */
    } plam_header_t;
    
    /*-------------------------------- Extended manifest --------------------*/
    typedef struct {
        plam_rva_t mods_dir;           /* Ğ”Ğ¾Ñ‡ĞµÑ€Ğ½Ğ¸Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ (Ğ´Ğ»Ñ composite binaries) */
        plam_rva_t l10n_table;         /* Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ»Ğ¾ĞºĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ */
        plam_rva_t src_repo;           /* URL Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ (Ğ´Ğ»Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ°) */
        uint32_t   abi_revision;       /* Ğ ĞµĞ²Ğ¸Ğ·Ğ¸Ñ ABI Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ */
        uint32_t   build_flags;        /* Ğ¤Ğ»Ğ°Ğ³Ğ¸ ÑĞ±Ğ¾Ñ€ĞºĞ¸ (LTO, PGO, debug) */
        
        /* Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ */
        plam_manifest_req_t requirements; /* ĞœĞ¸Ğ½. Ğ²ĞµÑ€ÑĞ¸Ñ ĞĞ¡, CPU features */
        
        uint32_t   min_kernel_api;     /* ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ API ÑĞ´Ñ€Ğ° */
        uint32_t   target_kernel_api;  /* Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ API ÑĞ´Ñ€Ğ° */
        
        /* ĞŸÑ€Ğ°Ğ²Ğ° Ğ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ */
        uint64_t   required_caps[2];   /* Ğ¢Ñ€ĞµĞ±ÑƒĞµĞ¼Ñ‹Ğµ capability-Ğ±Ğ¸Ñ‚Ñ‹ (128) */
        uint32_t   api_level;          /* Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ API (PlumOS SDK) */
        uint32_t   compat_flags;       /* Ğ¤Ğ»Ğ°Ğ³Ğ¸ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, legacy syscalls) */
    
        uint32_t   compat_level;       /* NEW: Compatibility level (e.g., for legacy syscalls) */
    
        /* Ğ—Ğ°Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ */
        uint8_t    reserved[28];       /* Adjusted reserved (was 32) */
    } plam_manifest_ext_t;
    
    /*-------------------------------- Resource descriptor ------------------*/
    typedef struct {
        uint32_t magic;              /* PLAM_RES_MAGIC */
        uint16_t type;               /* plam_res_type_t or vendor */
        uint16_t flags;              /* Resource flags */
        plam_rva_t blob;             /* Resource data */
        uint64_t orig_size;          /* Uncompressed size */
        uint8_t  comp_alg;           /* PLAM_COMP_* */
        uint8_t  comp_level;         /* Compression level */
        char     lang[6];            /* Localization (e.g. "en-US") */
        uint8_t  hash[48];           /* Integrity hash (BLAKE3-384) */
        uint8_t  reserved[2];
    } plam_resource_t;
    
    /*-------------------------------- Kernel module ------------------------*/
    #define PLAM_KMOD_LIVEPATCH   (1u << 0)  /* Supports live patching */
    #define PLAM_KMOD_SECURELOAD  (1u << 1)  /* Requires secure loading */
    #define PLAM_KMOD_HOT_SWAP    (1u << 2)  /* Hot swapping */
    #define PLAM_KMOD_SANDBOXED   (1u << 3)  /* Sandboxed execution */
    
    typedef struct {
        uint64_t mod_base;           /* Module base address */
        uint64_t mod_size;           /* Module size */
        uint64_t init_fn;            /* Initialization function */
        uint64_t fini_fn;            /* Finalization function */
        uint32_t req_kernel_ver;     /* Required kernel version */
        uint32_t min_kernel_ver;     /* Minimum kernel version */
        uint32_t flags;              /* PLAM_KMOD_* flags */
        uint32_t dep_count;          /* Dependency count */
        uint64_t dep_offset;         /* Dependency UUID list offset */
    } plam_kernelmod_t;
    
    #pragma pack(pop)    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ lib
    ğŸ“ plum-abi
        ğŸ“„ Cargo.toml
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [package]
        name = "plum-abi"
        version = "0.1.0"
        edition = "2021"
        
        [lib]
        path = "src/lib.rs"
        test = false
        bench = false
        
        [dependencies]        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ src
            ğŸ“„ lib.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #![no_std]
            
            
            pub mod types;
            pub mod syscall;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ syscall.rs
            [binary file skipped]
            ğŸ“„ types.rs
            [binary file skipped]
    ğŸ“ plum-formats
        ğŸ“„ Cargo.toml
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [package]
        name = "plum-formats"
        version = "0.1.0"
        edition = "2021"
        
        [lib]
        path = "src/lib.rs"
        test = false
        bench = false
        
        [dependencies]
        plum-hal = { path = "../plum-hal" }        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ src
            ğŸ“„ coff.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #[derive(Debug)]
            pub struct Coff;
            
            impl Coff {
                pub fn load(_data: &[u8]) -> Result<Self, &'static str> {
                    Err("COFF loader not implemented")
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ elf.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #[derive(Debug)]
            pub struct Elf {
                pub entry_offset: usize,
            }
            
            impl Elf {
                pub fn load(_data: &[u8]) -> Result<Self, &'static str> {
                    Ok(Self { entry_offset: 0 })
                }
            
                pub fn alloc_and_load(&self, _base: usize) -> Result<*mut u8, &'static str> {
                    unimplemented!("ELF loader not implemented")
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ lib.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #![no_std]
            
            
            pub mod elf;
            pub mod pe;
            pub mod macho;
            pub mod plam;
            pub mod coff;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ macho.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #[derive(Debug)]
            pub struct MachO;
            
            impl MachO {
                pub fn load(_data: &[u8]) -> Result<Self, &'static str> {
                    Err("Mach-O loader not implemented")
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ pe.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #[derive(Debug)]
            pub struct Pe;
            
            impl Pe {
                pub fn load(_data: &[u8]) -> Result<Self, &'static str> {
                    Err("PE loader not implemented")
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ plam.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub const PLAM_MAGIC: u32 = 0x504C414D;
            pub const PLAM_CPU_X86_64: u16 = 0x8664;
            pub const PLAM_CPU_ARM64: u16 = 0xAA64;
            pub const PLAM_CPU_RISCV64: u16 = 0x00F3;
            pub const PLAM_CPU_PRUM64: u16 = 0x7072;
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamHeader {
                pub magic: u32,
                pub version: u16,
                pub flags: u64,
                pub file_size: u64,
                pub hdr_crc32: u32,
                pub file_crc32: u32,
                pub format_version: u32,
                pub content_version: u32,
                pub image_base: u64,
                pub entry_offset: u64,
                pub stack_reserve: u64,
                pub stack_commit: u64,
                pub heap_reserve: u64,
                pub heap_commit: u64,
                pub cpu_id: u16,
                pub cpu_sub: u16,
                pub abi_version: u32,
                pub cpu_features: u64,
                pub os_abi: u32,
                pub os_version_min: u32,
                pub os_version_sdk: u32,
                pub str_table: PlamRva,
                pub sym_table: PlamRva,
                pub section_table_off: u64,
                pub section_count: u32,
                pub reloc_table_off: u64,
                pub reloc_count: u32,
                pub ph_off: u64,
                pub ph_count: u16,
                pub ph_entry_size: u16,
                pub resources: PlamRva,
                pub debug: PlamDebugInfo,
                pub uuid: [u8; 16],
                pub build_hash: [u8; 48],
                pub timestamp: u64,
                pub crypto_mode: u16,
                pub hash_type: u16,
                pub sig_scheme: u16,
                pub relro_level: u8,
                pub file_compression: u8,
                pub manifest: PlamRva,
                pub deps_count: u32,
                pub res_count: u32,
                pub lang_mask: u32,
                pub tool_major: u16,
                pub tool_minor: u16,
                pub tool_patch: u16,
                pub stdlib_ver: u16,
                pub comp_model: u8,
                pub lto_pgo_flags: u8,
                pub opt_level: u8,
                pub debug_level: u8,
                pub dirs: PlamDirectories,
                pub control_flow_start: u64,
                pub control_flow_size: u64,
                pub hotpatch_offset: u32,
                pub hotpatch_count: u32,
                pub subsystem_type: u16,
                pub subsystem_version: u16,
                pub subsystem_params: PlamSubsystemParams,
                pub subsystem_flags: u32,
                pub sec_flags: u16,
                pub sanitizer_level: u8,
                pub crypt_alg: u8,
                pub branch_prot: u8,
                pub prefetch_hint: u8,
                pub cache_align: u16,
                pub isolation_level: u8,
                pub namespace_flags: u8,
                pub container_features: u16,
                pub metadata_size: u64,
                pub build_info: PlamRva,
                pub api_constraints: PlamRva,
                pub code_size: u64,
                pub init_data_size: u64,
                pub uninit_data_size: u64,
                pub ext_hdr_off: u64,
                pub mem_regions: PlamRva,
                pub endian: u8,
                pub reserved: [u8; 63],
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamRva {
                pub off: u64,
                pub sz: u64,
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamDebugInfo {
                pub debug: PlamRva,
                pub debug_type: u16,
                pub debug_version: u16,
                pub debug_size: u32,
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamDirectories {
                pub security: PlamRva,
                pub loadcfg: PlamRva,
                pub tls: PlamRva,
                pub cfg: PlamRva,
                pub exceptions: PlamRva,
                pub basereloc: PlamRva,
                pub import_table: PlamRva,
                pub export_table: PlamRva,
                pub got: PlamRva,
                pub plt: PlamRva,
                pub subsystem_validator: PlamRva,
                pub fat_off: u64,
                pub fat_cnt: u32,
                pub fat_flags: u32,
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamSubsystemParams {
                pub raw: [u8; 24],
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamSection {
                pub name_off: u64,
                pub type_: u32,
                pub flags: u32,
                pub addr: u64,
                pub offset: u64,
                pub size: u64,
                pub entsize: u64,
                pub align: u64,
                pub section_prot: u32,
                pub comp_alg: u32,
                pub comp_level: u32,
                pub entropy: u32,
                pub hash_offset: u64,
            }
            
            #[repr(C, packed)]
            #[derive(Debug, Clone, Copy)]
            pub struct PlamReloc {
                pub offset: u64,
                pub type_: u32,
                pub sym_idx: u32,
                pub addend: i64,
                pub accelerator: u32,
                pub reserved: u32,
            }
            
            pub fn load_plam(buffer: &[u8], base: usize) -> Result<usize, &'static str> {
                if buffer.len() < core::mem::size_of::<PlamHeader>() {
                    return Err("PLAM: buffer too small for header");
                }
            
                if base % 4096 != 0 {
                    return Err("PLAM: base address must be page-aligned");
                }
            
                let header = unsafe { &*(buffer.as_ptr() as *const PlamHeader) };
            
                if header.magic != PLAM_MAGIC {
                    return Err("PLAM: invalid magic");
                }
            
                if header.version >> 8 != 3 {
                    return Err("PLAM: unsupported version");
                }
            
                // --- Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ±ĞµĞ· Vec ---
                if header.section_count > 0 {
                    let sections = unsafe {
                        core::slice::from_raw_parts(
                            buffer.as_ptr().add(header.section_table_off as usize) as *const PlamSection,
                            header.section_count as usize,
                        )
                    };
            
                    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚ ÑĞ¾ Ğ²ÑĞµĞ¼Ğ¸ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¼Ğ¸
                    for i in 0..sections.len() {
                        let sec_a = &sections[i];
                        let start_a = base + sec_a.addr as usize;
                        let end_a = start_a + sec_a.size as usize;
            
                        for j in (i + 1)..sections.len() {
                            let sec_b = &sections[j];
                            let start_b = base + sec_b.addr as usize;
                            let end_b = start_b + sec_b.size as usize;
            
                            if start_a < end_b && start_b < end_a {
                                return Err("PLAM: overlapping segments detected");
                            }
                        }
                    }
                }
            
                 if header.reloc_count > 0 {
                    let reloc_off = header.reloc_table_off as usize;
                    let reloc_size = core::mem::size_of::<PlamReloc>();
                    let total_reloc_bytes = header.reloc_count as usize * reloc_size;
            
                    if reloc_off + total_reloc_bytes > buffer.len() {
                        return Err("PLAM: reloc table out of bounds"); // Ğ›ÑƒÑ‡ÑˆĞµ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Result, Ğ° Ğ½Ğµ Ğ¿Ğ°Ğ½Ğ¸ĞºĞ¾Ğ²Ğ°Ñ‚ÑŒ
                    }
            
                    let relocs = unsafe {
                        core::slice::from_raw_parts(
                            buffer.as_ptr().add(reloc_off) as *const PlamReloc,
                            header.reloc_count as usize,
                        )
                    };
            
                    for rel in relocs {
                        let place = base + rel.offset as usize;
                        let value = base as u64 + rel.addend as u64;
            
                        match rel.type_ {
                            1 | 2 | 3 => {
                                unsafe {
                                    let ptr = place as *mut u64;
                                    *ptr += value;
                                }
                            }
                            _ => {}
                        }
                    }
                }
            
                Ok(base + header.entry_offset as usize)
            }
            
            pub struct PlamParser {
                base: *const u8,
            }
            
            impl PlamParser {
                pub fn new(base: *const u8) -> Self {
                    Self { base }
                }
            
                pub fn validate(&self) -> bool {
                    unsafe {
                        let header = &*(self.base as *const PlamHeader);
                        header.magic == 0x504C414D
                    }
                }
            
                pub fn entry_point(&self) -> Result<usize, &'static str> {
                    unsafe {
                        let header = &*(self.base as *const PlamHeader);
                        if !self.validate() {
                            return Err("Invalid PLAM magic");
                        }
                        let entry = header.image_base as usize + header.entry_offset as usize;
                        Ok(entry)
                    }
                }
            
                pub fn load_segments(&self) {
                    // ĞšĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ¹: Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ¾Ğ² (loadable PT_LOAD). Stub: ĞŸÑ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ ĞºĞ¾Ğ´ Ğ¿Ğ¾ÑĞ»Ğµ 4096.
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ plum-hal
        ğŸ“„ Cargo.toml
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [package]
        name = "plum-hal"
        version = "0.1.0"
        edition = "2021"
        
        [lib]
        path = "src/lib.rs"
        test = false
        bench = false
        
        [dependencies]
        log = { version = "0.4", default-features = false }
        spin = "0.10.0"
        
        [features]
        uefi = []
        default = []        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ src
            ğŸ“ block
                ğŸ“„ ahci.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use crate::block::{BlockDevice, BlockError};
                
                pub struct AhciController {
                    base: usize,
                }
                
                impl AhciController {
                    pub const unsafe fn new(base: usize) -> Self {
                        Self { base }
                    }
                    fn mmio_read(&self, reg: usize) -> u32 {
                        unsafe { ((self.base + reg) as *const u32).read_volatile() }
                    }
                    fn mmio_write(&self, reg: usize, value: u32) {
                        unsafe { ((self.base + reg) as *mut u32).write_volatile(value); }
                    }
                    pub fn init(&mut self) -> Result<(), &'static str> {
                        let cap = self.mmio_read(0x00);
                        if cap & (1 << 31) == 0 {
                            return Err("Controller does not support AHCI");
                        }
                        let ghc = self.mmio_read(0x04);
                        self.mmio_write(0x04, ghc | (1 << 31));
                        log::info!("AHCI Controller initialized");
                        Ok(())
                    }
                    pub fn detect_ports(&self) -> u32 {
                        let pi = self.mmio_read(0x0C);
                        log::debug!("AHCI Ports implemented: {:032b}", pi);
                        pi
                    }
                }
                
                impl BlockDevice for AhciController {
                    fn read_blocks(&mut self, _lba: u64, _buffer: &mut [u8]) -> Result<(), BlockError> {
                        Err(BlockError::IoError)
                    }
                    fn write_blocks(&mut self, _lba: u64, _buffer: &[u8]) -> Result<(), BlockError> {
                        Err(BlockError::IoError)
                    }
                    fn block_size(&self) -> usize { 512 }
                    fn block_count(&self) -> u64 { 0 }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ mod.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub mod ahci;
                pub mod nvme;
                pub mod sdhci;
                
                pub use ahci::AhciController;
                pub use nvme::NvmeController;
                pub use sdhci::SdhciController;
                
                use spin::Mutex;
                
                
                #[derive(Debug)]
                pub enum BlockError {
                    DeviceError,
                    Timeout,
                    InvalidParameter,
                    NotSupported,
                    IoError,
                }
                
                impl From<&'static str> for BlockError {
                    fn from(_: &'static str) -> Self {
                        BlockError::IoError
                    }
                }
                
                pub type BlockResult<T> = Result<T, BlockError>;
                
                pub trait BlockDevice {
                    fn read_blocks(&mut self, lba: u64, buffer: &mut [u8]) -> BlockResult<()>;
                    fn write_blocks(&mut self, lba: u64, buffer: &[u8]) -> BlockResult<()>;
                    fn block_size(&self) -> usize;
                    fn block_count(&self) -> u64;
                    fn supports_dma(&self) -> bool { false }
                    fn flush(&mut self) -> BlockResult<()> { Ok(()) }
                }
                
                pub enum BlockDeviceType {
                    Ahci(AhciController),
                    Nvme(NvmeController),
                    SdCard(SdhciController),
                }
                
                impl BlockDevice for BlockDeviceType {
                    fn read_blocks(&mut self, lba: u64, buffer: &mut [u8]) -> BlockResult<()> {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.read_blocks(lba, buffer),
                            BlockDeviceType::Nvme(dev) => dev.read_blocks(lba, buffer),
                            BlockDeviceType::SdCard(dev) => dev.read_blocks(lba, buffer),
                        }
                    }
                    fn write_blocks(&mut self, lba: u64, buffer: &[u8]) -> BlockResult<()> {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.write_blocks(lba, buffer),
                            BlockDeviceType::Nvme(dev) => dev.write_blocks(lba, buffer),
                            BlockDeviceType::SdCard(dev) => dev.write_blocks(lba, buffer),
                        }
                    }
                    fn block_size(&self) -> usize {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.block_size(),
                            BlockDeviceType::Nvme(dev) => dev.block_size(),
                            BlockDeviceType::SdCard(dev) => dev.block_size(),
                        }
                    }
                    fn block_count(&self) -> u64 {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.block_count(),
                            BlockDeviceType::Nvme(dev) => dev.block_count(),
                            BlockDeviceType::SdCard(dev) => dev.block_count(),
                        }
                    }
                    fn supports_dma(&self) -> bool {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.supports_dma(),
                            BlockDeviceType::Nvme(dev) => dev.supports_dma(),
                            BlockDeviceType::SdCard(dev) => dev.supports_dma(),
                        }
                    }
                    fn flush(&mut self) -> BlockResult<()> {
                        match self {
                            BlockDeviceType::Ahci(dev) => dev.flush(),
                            BlockDeviceType::Nvme(dev) => dev.flush(),
                            BlockDeviceType::SdCard(dev) => dev.flush(),
                        }
                    }
                }
                
                pub struct BlockDeviceManager {
                    devices: [Option<BlockDeviceType>; 8],
                    count: usize,
                }
                
                impl BlockDeviceManager {
                    pub const fn new() -> Self {
                        Self {
                            devices: [
                                None, None, None, None,
                                None, None, None, None,
                            ],
                            count: 0,
                        }
                    }
                    pub fn add_device(&mut self, device: BlockDeviceType) -> BlockResult<()> {
                        if self.count >= self.devices.len() {
                            return Err(BlockError::NotSupported);
                        }
                        if device.block_count() == 0 {
                            return Err(BlockError::DeviceError);
                        }
                        self.devices[self.count] = Some(device);
                        self.count += 1;
                        Ok(())
                    }
                    pub fn get_device(&mut self, index: usize) -> Option<&mut BlockDeviceType> {
                        if index < self.count {
                            self.devices[index].as_mut()
                        } else {
                            None
                        }
                    }
                    pub fn get_device_by_name(&mut self, _name: &str) -> Option<&mut BlockDeviceType> {
                        // Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: _name Ğ²Ğ¼ĞµÑÑ‚Ğ¾ name
                        self.devices[0..self.count].iter_mut().find_map(|dev| dev.as_mut())
                    }
                    pub fn device_count(&self) -> usize {
                        self.count
                    }
                    pub fn total_capacity(&self) -> u64 {
                        let mut total = 0;
                        for i in 0..self.count {
                            if let Some(dev) = &self.devices[i] {
                                total += dev.block_count() * dev.block_size() as u64;
                            }
                        }
                        total
                    }
                }
                
                static BLOCK_DEVICE_MANAGER: Mutex<BlockDeviceManager> = Mutex::new(BlockDeviceManager::new());
                
                pub fn init_block_devices() -> BlockResult<()> {
                    let mut mgr = BLOCK_DEVICE_MANAGER.lock();
                    log::info!("Initializing block devices...");
                    #[cfg(target_arch = "x86_64")]
                    {
                        log::info!("Detecting AHCI controllers...");
                        let mut ahci = unsafe { AhciController::new(0x400000) };
                        if ahci.init().is_ok() {
                            if let Err(e) = mgr.add_device(BlockDeviceType::Ahci(ahci)) {
                                log::warn!("Failed to add AHCI device: {:?}", e);
                            } else {
                                log::info!("AHCI controller initialized");
                            }
                        }
                    }
                    #[cfg(target_arch = "aarch64")]
                    {
                        log::info!("Detecting SDHCI controllers...");
                        let mut sdhci = SdhciController::new(0x7E200000);
                        if sdhci.init().is_ok() {
                            if let Err(e) = mgr.add_device(BlockDeviceType::SdCard(sdhci)) {
                                log::warn!("Failed to add SD card device: {:?}", e);
                            } else {
                                log::info!("SDHCI controller initialized");
                            }
                        }
                    }
                    #[cfg(target_arch = "riscv64")]
                    {
                        log::info!("Detecting NVMe controllers...");
                        let mut nvme = unsafe { NvmeController::new(0x30000000) };
                        if nvme.init().is_ok() {
                            if let Err(e) = mgr.add_device(BlockDeviceType::Nvme(nvme)) {
                                log::warn!("Failed to add NVMe device: {:?}", e);
                            } else {
                                log::info!("NVMe controller initialized");
                            }
                        }
                    }
                    log::info!("Block devices initialized: {}", mgr.device_count());
                    log::info!("Total storage capacity: {} bytes", mgr.total_capacity());
                    if mgr.device_count() == 0 {
                        log::warn!("No block devices found!");
                        return Err(BlockError::DeviceError);
                    }
                    Ok(())
                }
                
                pub fn get_block_device_manager() -> spin::MutexGuard<'static, BlockDeviceManager> {
                    BLOCK_DEVICE_MANAGER.lock()
                }
                
                // Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ°Ğ¼Ğ¸
                pub mod partition {
                    use super::*;
                
                    #[repr(C, packed)]
                    #[derive(Debug, Copy, Clone)]
                    pub struct MbrPartition {
                        pub status: u8,
                        pub chs_start: [u8; 3],
                        pub type_code: u8,
                        pub chs_end: [u8; 3],
                        pub lba_start: u32,
                        pub sector_count: u32,
                    }
                
                    #[repr(C, packed)]
                    #[derive(Debug, Copy, Clone)] // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Copy
                    pub struct Mbr {
                        pub bootstrap: [u8; 446],
                        pub partitions: [MbrPartition; 4],
                        pub signature: u16,
                    }
                
                    pub fn read_mbr(device: &mut dyn BlockDevice) -> BlockResult<Mbr> {
                        let mut mbr_data = [0u8; 512];
                        device.read_blocks(0, &mut mbr_data)?;
                        unsafe {
                            let mbr = &*(mbr_data.as_ptr() as *const Mbr);
                            if mbr.signature != 0xAA55 {
                                return Err(BlockError::InvalidParameter);
                            }
                            Ok(*mbr) // Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾, Ñ‚.Ğº. Mbr: Copy
                        }
                    }
                
                    pub fn is_valid_partition(partition: &MbrPartition) -> bool {
                        partition.type_code != 0 && partition.sector_count > 0
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ nvme.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use crate::block::{BlockDevice, BlockError};
                
                pub struct NvmeController {
                    base: usize,
                }
                
                impl NvmeController {
                    pub const unsafe fn new(base: usize) -> Self {
                        Self { base }
                    }
                    fn mmio_read(&self, reg: usize) -> u32 {
                        unsafe { ((self.base + reg) as *const u32).read_volatile() }
                    }
                    #[allow(dead_code)]
                    fn mmio_write(&self, reg: usize, value: u32) {
                        unsafe { ((self.base + reg) as *mut u32).write_volatile(value); }
                    }
                    pub fn init(&mut self) -> Result<(), &'static str> {
                        let vs = self.mmio_read(0x08);
                        log::info!("NVMe Version: {}.{}", (vs >> 16) & 0xffff, vs & 0xffff);
                        log::info!("NVMe Controller initialized");
                        Ok(())
                    }
                }
                
                impl BlockDevice for NvmeController {
                    fn read_blocks(&mut self, _lba: u64, _buffer: &mut [u8]) -> Result<(), BlockError> {
                        Err(BlockError::IoError)
                    }
                    fn write_blocks(&mut self, _lba: u64, _buffer: &[u8]) -> Result<(), BlockError> {
                        Err(BlockError::IoError)
                    }
                    fn block_size(&self) -> usize { 512 }
                    fn block_count(&self) -> u64 { 0 }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ sdhci.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use crate::block::{BlockDevice, BlockError};
                use core::ptr;
                use core::sync::atomic::{fence, Ordering};
                use log::{info, warn};
                
                // Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñ‹ SDHCI
                const SDHCI_DMA_ADDRESS: usize = 0x00;
                const SDHCI_BLOCK_SIZE: usize = 0x04;
                const SDHCI_BLOCK_COUNT: usize = 0x06;
                const SDHCI_ARGUMENT: usize = 0x08;
                const SDHCI_TRANSFER_MODE: usize = 0x0C;
                const SDHCI_COMMAND: usize = 0x0E;
                const SDHCI_RESPONSE_0: usize = 0x10;
                const SDHCI_RESPONSE_1: usize = 0x14;
                const SDHCI_RESPONSE_2: usize = 0x18;
                const SDHCI_RESPONSE_3: usize = 0x1C;
                const SDHCI_PRESENT_STATE: usize = 0x24;
                const SDHCI_HOST_CONTROL_1: usize = 0x28;
                const SDHCI_CLOCK_CONTROL: usize = 0x2C;
                const SDHCI_SOFTWARE_RESET: usize = 0x2F;
                const SDHCI_INT_STATUS: usize = 0x30;
                const SDHCI_INT_ENABLE: usize = 0x34;
                
                // ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ SD
                const CMD_GO_IDLE_STATE: u16 = 0;
                const CMD_SEND_IF_COND: u16 = 8;
                const CMD_APP_CMD: u16 = 55;
                const ACMD_SD_SEND_OP_COND: u16 = 41;
                const CMD_ALL_SEND_CID: u16 = 2;
                const CMD_SEND_RELATIVE_ADDR: u16 = 3;
                const CMD_SELECT_CARD: u16 = 7;
                const CMD_SEND_CSD: u16 = 9;
                const CMD_SET_BLOCKLEN: u16 = 16;
                const CMD_READ_SINGLE_BLOCK: u16 = 17;
                const CMD_READ_MULTIPLE_BLOCK: u16 = 18;
                const CMD_WRITE_SINGLE_BLOCK: u16 = 24;
                const CMD_WRITE_MULTIPLE_BLOCK: u16 = 25;
                const CMD_STOP_TRANSMISSION: u16 = 12;
                
                // Ğ¤Ğ»Ğ°Ğ³Ğ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
                const SDHCI_CMD_RESP_NONE: u16 = 0x0000;
                const SDHCI_CMD_RESP_R1: u16 = 0x0010;
                const SDHCI_CMD_RESP_R2: u16 = 0x0018;
                const SDHCI_CMD_RESP_R3: u16 = 0x0010;
                const SDHCI_CMD_RESP_R6: u16 = 0x0010;
                const SDHCI_CMD_CRC_EN: u16 = 0x0008;
                const SDHCI_CMD_INDEX_EN: u16 = 0x0004;
                const SDHCI_CMD_DATA: u16 = 0x0020;
                
                // Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
                const SDHCI_CMD_INHIBIT: u32 = 1 << 0;
                const SDHCI_DATA_INHIBIT: u32 = 1 << 1;
                const SDHCI_CARD_PRESENT: u32 = 1 << 16;
                
                // ĞŸÑ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ
                const SDHCI_INT_RESPONSE: u32 = 1 << 0;
                const SDHCI_INT_DATA_END: u32 = 1 << 1;
                const SDHCI_INT_DATA_CRC_ERR: u32 = 1 << 8;
                const SDHCI_INT_DATA_TIMEOUT: u32 = 1 << 9;
                const SDHCI_INT_ERROR: u32 = 1 << 15;
                
                // ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ
                const SDHCI_CTRL_4BITBUS: u8 = 0x02;
                const SDHCI_CLOCK_INT_EN: u16 = 1 << 0;
                const SDHCI_CLOCK_INT_STABLE: u16 = 1 << 1;
                const SDHCI_CLOCK_CARD_EN: u16 = 1 << 2;
                const SDHCI_RESET_ALL: u8 = 0x01;
                
                const BLOCK_SIZE: u16 = 512;
                const MAX_RETRIES: usize = 1_000_000;
                
                #[repr(align(128))]
                struct AlignedBuffer([u8; 512]);
                
                impl AlignedBuffer {
                    const fn new() -> Self {
                        Self([0; 512])
                    }
                }
                
                #[derive(Debug, Clone, Copy)]
                enum CardType {
                    None,
                    SDSC,
                    SDHC,
                    SDXC,
                }
                
                pub struct SdhciController {
                    base: usize,
                    rca: u32,
                    card_type: CardType,
                    block_count: u64,
                }
                
                impl SdhciController {
                    pub const fn new(base: usize) -> Self {
                        Self {
                            base,
                            rca: 0,
                            card_type: CardType::None,
                            block_count: 0,
                        }
                    }
                
                    #[inline]
                    fn read32(&self, reg: usize) -> u32 {
                        let val = unsafe { ptr::read_volatile((self.base + reg) as *const u32) };
                        fence(Ordering::Acquire);
                        val
                    }
                
                    #[inline]
                    fn write32(&self, reg: usize, val: u32) {
                        fence(Ordering::Release);
                        unsafe { ptr::write_volatile((self.base + reg) as *mut u32, val) };
                    }
                
                    #[inline]
                    fn read16(&self, reg: usize) -> u16 {
                        let val = unsafe { ptr::read_volatile((self.base + reg) as *const u16) };
                        fence(Ordering::Acquire);
                        val
                    }
                
                    #[inline]
                    fn write16(&self, reg: usize, val: u16) {
                        fence(Ordering::Release);
                        unsafe { ptr::write_volatile((self.base + reg) as *mut u16, val) };
                    }
                
                    #[inline]
                    fn read8(&self, reg: usize) -> u8 {
                        let val = unsafe { ptr::read_volatile((self.base + reg) as *const u8) };
                        fence(Ordering::Acquire);
                        val
                    }
                
                    #[inline]
                    fn write8(&self, reg: usize, val: u8) {
                        fence(Ordering::Release);
                        unsafe { ptr::write_volatile((self.base + reg) as *mut u8, val) };
                    }
                
                    fn wait_for_cmd(&self) -> Result<(), &'static str> {
                        for _ in 0..MAX_RETRIES {
                            if self.read32(SDHCI_PRESENT_STATE) & SDHCI_CMD_INHIBIT == 0 {
                                return Ok(());
                            }
                        }
                        Err("Timeout waiting for CMD inhibit")
                    }
                
                    fn wait_for_data(&self) -> Result<(), &'static str> {
                        for _ in 0..MAX_RETRIES {
                            if self.read32(SDHCI_PRESENT_STATE) & SDHCI_DATA_INHIBIT == 0 {
                                return Ok(());
                            }
                        }
                        Err("Timeout waiting for DATA inhibit")
                    }
                
                    fn wait_for_interrupt(&self, mask: u32) -> Result<u32, &'static str> {
                        for _ in 0..MAX_RETRIES {
                            let int_status = self.read32(SDHCI_INT_STATUS);
                            
                            // Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
                            if int_status & SDHCI_INT_DATA_CRC_ERR != 0 {
                                return Err("SDHCI data CRC error");
                            }
                            if int_status & SDHCI_INT_DATA_TIMEOUT != 0 {
                                return Err("SDHCI data timeout");
                            }
                            if int_status & (SDHCI_INT_ERROR & !(SDHCI_INT_DATA_CRC_ERR | SDHCI_INT_DATA_TIMEOUT)) != 0 {
                                return Err("SDHCI hardware error");
                            }
                            
                            if int_status & mask != 0 {
                                self.write32(SDHCI_INT_STATUS, int_status);
                                return Ok(int_status);
                            }
                        }
                        Err("SDHCI operation timeout")
                    }
                
                    fn reset(&self) {
                        self.write8(SDHCI_SOFTWARE_RESET, SDHCI_RESET_ALL);
                        while self.read8(SDHCI_SOFTWARE_RESET) & SDHCI_RESET_ALL != 0 {}
                    }
                
                    fn init_clock(&self) -> Result<(), &'static str> {
                        self.write16(SDHCI_CLOCK_CONTROL, SDHCI_CLOCK_INT_EN);
                        
                        for _ in 0..MAX_RETRIES {
                            if self.read16(SDHCI_CLOCK_CONTROL) & SDHCI_CLOCK_INT_STABLE != 0 {
                                break;
                            }
                        }
                        
                        let clk = self.read16(SDHCI_CLOCK_CONTROL);
                        self.write16(SDHCI_CLOCK_CONTROL, clk | SDHCI_CLOCK_CARD_EN);
                        
                        Ok(())
                    }
                
                    fn set_high_speed(&self) {
                        let clk = self.read16(SDHCI_CLOCK_CONTROL);
                        self.write16(SDHCI_CLOCK_CONTROL, clk & !(0xFF << 8));
                    }
                
                    fn send_command(&self, cmd: u16, arg: u32, flags: u16) -> Result<u32, &'static str> {
                        self.wait_for_cmd()?;
                        self.write32(SDHCI_ARGUMENT, arg);
                        self.write16(SDHCI_COMMAND, (cmd << 8) | flags);
                        self.wait_for_interrupt(SDHCI_INT_RESPONSE)?;
                        Ok(self.read32(SDHCI_RESPONSE_0))
                    }
                
                    fn is_card_present(&self) -> bool {
                        self.read32(SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT != 0
                    }
                
                    fn parse_csd(&mut self, csd: [u32; 4]) -> Result<(), &'static str> {
                        let csd_structure = (csd[0] >> 30) & 0x3;
                        
                        match csd_structure {
                            0 => {
                                let c_size = ((csd[1] & 0x3FF) << 2) | ((csd[2] >> 30) & 0x3);
                                let c_size_mult = ((csd[2] >> 15) & 0x7) as u64;
                                let read_bl_len = ((csd[1] >> 16) & 0xF) as u64;
                                
                                let block_len = 1u64 << read_bl_len;
                                let mult = 1u64 << (c_size_mult + 2);
                                let capacity = (c_size as u64 + 1) * mult * block_len;
                                
                                self.block_count = capacity / 512;
                                self.card_type = CardType::SDSC;
                            }
                            1 => {
                                let c_size = (((csd[1] & 0x3F) as u64) << 16) | ((csd[2] >> 16) as u64);
                                self.block_count = (c_size + 1) * 1024;
                                self.card_type = if self.block_count > 0x80000000 {
                                    CardType::SDXC
                                } else {
                                    CardType::SDHC
                                };
                            }
                            _ => return Err("Unknown CSD version"),
                        }
                        
                        Ok(())
                    }
                
                    pub fn init(&mut self) -> Result<(), &'static str> {
                        if !self.is_card_present() {
                            return Err("No SD card present");
                        }
                
                        info!("SDHCI: Initializing controller at {:#x}", self.base);
                        
                        self.reset();
                        self.init_clock()?;
                        self.write32(SDHCI_INT_ENABLE, SDHCI_INT_RESPONSE | SDHCI_INT_DATA_END | SDHCI_INT_ERROR);
                
                        self.send_command(CMD_GO_IDLE_STATE, 0, SDHCI_CMD_RESP_NONE)?;
                
                        let resp = self.send_command(
                            CMD_SEND_IF_COND, 
                            0x1AA, 
                            SDHCI_CMD_RESP_R1 | SDHCI_CMD_CRC_EN | SDHCI_CMD_INDEX_EN
                        )?;
                        
                        if resp & 0xFFF != 0x1AA {
                            warn!("SDHCI: Card doesn't support required voltage");
                        }
                
                        let mut ocr = 0x40300000;
                        for _ in 0..1000 {
                            self.send_command(CMD_APP_CMD, 0, SDHCI_CMD_RESP_R1)?;
                            let resp = self.send_command(ACMD_SD_SEND_OP_COND, ocr, SDHCI_CMD_RESP_R3)?;
                            if resp & (1 << 31) != 0 {
                                ocr = resp;
                                break;
                            }
                        }
                
                        if ocr & (1 << 31) == 0 {
                            return Err("Card initialization timeout");
                        }
                
                        if ocr & (1 << 30) != 0 {
                            self.card_type = CardType::SDHC;
                        }
                
                        self.send_command(CMD_ALL_SEND_CID, 0, SDHCI_CMD_RESP_R2)?;
                        let rca_resp = self.send_command(CMD_SEND_RELATIVE_ADDR, 0, SDHCI_CMD_RESP_R6)?;
                        self.rca = (rca_resp >> 16) & 0xFFFF;
                        
                        if self.rca == 0 {
                            return Err("Invalid RCA received");
                        }
                
                        self.send_command(CMD_SELECT_CARD, self.rca << 16, SDHCI_CMD_RESP_R1)?;
                
                        let csd_resp = [
                            self.send_command(CMD_SEND_CSD, self.rca << 16, SDHCI_CMD_RESP_R2)?,
                            self.read32(SDHCI_RESPONSE_1),
                            self.read32(SDHCI_RESPONSE_2),
                            self.read32(SDHCI_RESPONSE_3),
                        ];
                        
                        self.parse_csd(csd_resp)?;
                        self.send_command(CMD_SET_BLOCKLEN, BLOCK_SIZE as u32, SDHCI_CMD_RESP_R1)?;
                        self.set_high_speed();
                
                        let mut host_ctrl = self.read8(SDHCI_HOST_CONTROL_1);
                        host_ctrl |= SDHCI_CTRL_4BITBUS;
                        self.write8(SDHCI_HOST_CONTROL_1, host_ctrl);
                
                        info!("SDHCI: Card initialized (RCA: {:#x}, Type: {:?}, Blocks: {})",
                            self.rca, self.card_type, self.block_count);
                
                        Ok(())
                    }
                
                    fn transfer_blocks(&self, lba: u64, buffer: &mut [u8], write: bool) -> Result<(), &'static str> {
                        let block_count = (buffer.len() / 512) as u16;
                        if block_count == 0 || buffer.len() % 512 != 0 {
                            return Err("Buffer size must be multiple of 512 bytes");
                        }
                
                        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ DMA Ğ±ÑƒÑ„ĞµÑ€Ğ°
                        if buffer.as_ptr() as usize % 4 != 0 {
                            return Err("Buffer must be 4-byte aligned for DMA");
                        }
                
                        let addr = match self.card_type {
                            CardType::SDSC => lba * 512,
                            _ => lba,
                        };
                
                        self.wait_for_data()?;
                        self.write16(SDHCI_BLOCK_SIZE, BLOCK_SIZE);
                        self.write16(SDHCI_BLOCK_COUNT, block_count);
                
                        let transfer_mode = 0x0002 | if block_count > 1 { 0x0020 } else { 0x0000 };
                        self.write16(SDHCI_TRANSFER_MODE, transfer_mode);
                
                        let dma_addr = buffer.as_ptr() as u32;
                        self.write32(SDHCI_DMA_ADDRESS, dma_addr);
                
                        let cmd = match (write, block_count > 1) {
                            (false, true) => CMD_READ_MULTIPLE_BLOCK,
                            (false, false) => CMD_READ_SINGLE_BLOCK,
                            (true, true) => CMD_WRITE_MULTIPLE_BLOCK,
                            (true, false) => CMD_WRITE_SINGLE_BLOCK,
                        };
                
                        let cmd_flags = SDHCI_CMD_RESP_R1 | SDHCI_CMD_CRC_EN | SDHCI_CMD_INDEX_EN | SDHCI_CMD_DATA;
                        self.send_command(cmd, addr as u32, cmd_flags)?;
                
                        self.wait_for_interrupt(SDHCI_INT_DATA_END)?;
                
                        if !write && block_count > 1 {
                            self.send_command(CMD_STOP_TRANSMISSION, 0, SDHCI_CMD_RESP_R1)?;
                        }
                
                        Ok(())
                    }
                }
                
                impl BlockDevice for SdhciController {
                    fn read_blocks(&mut self, lba: u64, buffer: &mut [u8]) -> Result<(), BlockError> {
                        self.transfer_blocks(lba, buffer, false).map_err(|_| BlockError::IoError)
                    }
                    fn write_blocks(&mut self, lba: u64, buffer: &[u8]) -> Result<(), BlockError> {
                        if buffer.len() % 512 != 0 {
                            return Err(BlockError::InvalidParameter);
                        }
                        let mut dma_buffer = AlignedBuffer::new();
                        for (i, chunk) in buffer.chunks(512).enumerate() {
                            dma_buffer.0[..chunk.len()].copy_from_slice(chunk);
                            let block_lba = lba + i as u64;
                            let dma_slice = unsafe {
                                core::slice::from_raw_parts_mut(
                                    &mut dma_buffer.0 as *mut [u8; 512] as *mut u8,
                                    512,
                                )
                            };
                            self.transfer_blocks(block_lba, dma_slice, true)
                                .map_err(|_| BlockError::IoError)?;
                        }
                        Ok(())
                    }
                    fn block_size(&self) -> usize { BLOCK_SIZE as usize }
                    fn block_count(&self) -> u64 { self.block_count }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ lib.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            #![no_std]
            
            pub mod uart;
            pub mod block;
            
            #[derive(Debug, Clone, Copy)]
            pub enum HalError {
                DeviceNotFound,
                Timeout,
                InvalidParameter,
                NotSupported,
                IoError,
            }
            
            impl From<block::BlockError> for HalError {
                fn from(error: block::BlockError) -> Self {
                    match error {
                        block::BlockError::DeviceError => HalError::DeviceNotFound,
                        block::BlockError::Timeout => HalError::Timeout,
                        block::BlockError::InvalidParameter => HalError::InvalidParameter,
                        block::BlockError::NotSupported => HalError::NotSupported,
                        block::BlockError::IoError => HalError::IoError,
                    }
                }
            }
            
            impl From<&'static str> for HalError {
                fn from(_: &'static str) -> Self {
                    HalError::IoError
                }
            }
            
            pub type HalResult<T> = Result<T, HalError>;
            
            pub trait Uart {
                fn init(&mut self) -> HalResult<()>;
                fn putc(&mut self, c: u8) -> HalResult<()>;
                fn getc(&mut self) -> HalResult<Option<u8>>;
                fn puts(&mut self, s: &str) -> HalResult<()> {
                    for &b in s.as_bytes() {
                        self.putc(b)?;
                    }
                    Ok(())
                }
                fn write(&mut self, data: &[u8]) -> HalResult<()> {
                    for &byte in data {
                        self.putc(byte)?;
                    }
                    Ok(())
                }
                fn read(&mut self, buffer: &mut [u8]) -> HalResult<usize> {
                    let mut count = 0;
                    for byte in buffer.iter_mut() {
                        match self.getc()? {
                            Some(b) => {
                                *byte = b;
                                count += 1;
                            }
                            None => break,
                        }
                    }
                    Ok(count)
                }
            }
            
            pub trait Timer {
                fn init(&mut self) -> HalResult<()>;
                fn set_interval(&mut self, interval_ns: u64) -> HalResult<()>;
                fn get_counter(&self) -> HalResult<u64>;
                fn enable(&mut self) -> HalResult<()>;
                fn disable(&mut self) -> HalResult<()>;
            }
            
            #[macro_export]
            macro_rules! debug_print {
                ($($arg:tt)*) => {
                    #[cfg(feature = "debug")]
                    {
                        use crate::hal::Uart;
                        if let Some(uart) = crate::hal::uart::get_default_uart() {
                            let _ = uart.lock().puts(&format!($($arg)*));
                        }
                    }
                };
            }
            
            #[macro_export]
            macro_rules! debug_println {
                ($($arg:tt)*) => {
                    $crate::debug_print!($($arg)*);
                    $crate::debug_print!("\n");
                };
            }
            
            pub fn init_hal() -> HalResult<()> {
                 #[cfg(all(
                    any(target_arch = "x86_64", target_arch = "riscv64"),
                    not(feature = "uefi")
                ))]
                crate::uart::init_default_uart()?;
            
                crate::block::init_block_devices()?;
                Ok(())
            }
            
            pub mod memory {
                use core::ptr;
            
                pub fn memset(dest: *mut u8, value: u8, count: usize) {
                    unsafe {
                        ptr::write_bytes(dest, value, count);
                    }
                }
            
                pub fn memcpy(dest: *mut u8, src: *const u8, count: usize) {
                    unsafe {
                        ptr::copy_nonoverlapping(src, dest, count);
                    }
                }
            
                pub fn memmove(dest: *mut u8, src: *const u8, count: usize) {
                    unsafe {
                        ptr::copy(src, dest, count);
                    }
                }
            
                pub fn memcmp(s1: *const u8, s2: *const u8, count: usize) -> i32 {
                    for i in 0..count {
                        unsafe {
                            let a = *s1.add(i);
                            let b = *s2.add(i);
                            if a != b {
                                return a as i32 - b as i32;
                            }
                        }
                    }
                    0
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“ uart
                ğŸ“„ mod.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                #[cfg(target_arch = "aarch64")]
                pub mod pl011;
                
                #[cfg(target_arch = "x86_64")]
                pub mod ns16550;
                
                #[cfg(target_arch = "riscv64")]
                pub mod uart16550;
                
                #[cfg(target_arch = "aarch64")]
                pub use pl011::Pl011Uart as DefaultUart;
                
                #[cfg(target_arch = "x86_64")]
                pub use ns16550::Ns16550Uart as DefaultUart;
                
                #[cfg(target_arch = "riscv64")]
                pub use uart16550::Uart16550 as DefaultUart;
                
                use crate::Uart;
                use spin::Mutex;
                use crate::HalResult;
                
                #[cfg(target_arch = "x86_64")]
                static DEFAULT_UART: Mutex<Option<DefaultUart>> = Mutex::new(None);
                
                #[cfg(target_arch = "x86_64")]
                pub fn init_default_uart() -> HalResult<()> {
                    let mut uart = unsafe { DefaultUart::new(0x3F8) };
                    uart.init()?;
                    *DEFAULT_UART.lock() = Some(uart);
                    Ok(())
                }
                
                #[cfg(not(target_arch = "x86_64"))]
                pub fn init_default_uart() -> HalResult<()> {
                    Ok(())
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ ns16550.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use crate::Uart;
                use crate::HalResult;
                
                pub struct Ns16550Uart {
                    base: usize,
                }
                
                impl Ns16550Uart {
                    pub const unsafe fn new(base: usize) -> Self {
                        Self { base }
                    }
                
                    fn outb(&self, reg: usize, value: u8) {
                        unsafe {
                            ((self.base + reg) as *mut u8).write_volatile(value);
                        }
                    }
                
                    fn inb(&self, reg: usize) -> u8 {
                        unsafe {
                            ((self.base + reg) as *const u8).read_volatile()
                        }
                    }
                }
                
                impl Uart for Ns16550Uart {
                    fn init(&mut self) -> HalResult<()> {
                        self.outb(1, 0x00); // Disable interrupts
                        self.outb(3, 0x80); // Enable DLAB
                        self.outb(0, 0x03); // Baud rate divisor low
                        self.outb(1, 0x00); // Baud rate divisor high
                        self.outb(3, 0x03); // 8N1, disable DLAB
                        self.outb(2, 0xC7); // Enable FIFO
                        Ok(())
                    }
                
                    fn putc(&mut self, c: u8) -> HalResult<()> {
                        while self.inb(5) & 0x20 == 0 {}
                        self.outb(0, c);
                        Ok(())
                    }
                
                    fn getc(&mut self) -> HalResult<Option<u8>> {
                        if self.inb(5) & 0x01 != 0 {
                            Ok(Some(self.inb(0)))
                        } else {
                            Ok(None)
                        }
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ pl011.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub struct Pl011Uart {
                    base: usize,
                }
                
                impl Pl011Uart {
                    pub const fn new(base: usize) -> Self {
                        Self { base }
                    }
                
                    fn mmio_write(&self, reg: usize, val: u32) {
                        unsafe { ((self.base + reg) as *mut u32).write_volatile(val) }
                    }
                
                    fn mmio_read(&self, reg: usize) -> u32 {
                        unsafe { ((self.base + reg) as *const u32).read_volatile() }
                    }
                
                    pub fn init(&self) {
                        
                        self.mmio_write(0x30, 0x0000);
                
                        
                        self.mmio_write(0x24, 1); 
                        self.mmio_write(0x28, 40); 
                
                        
                        self.mmio_write(0x2C, (1 << 4) | (3 << 5));
                
                        
                        self.mmio_write(0x30, (1 << 0) | (1 << 8) | (1 << 9));
                    }
                
                    pub fn putc(&self, c: u8) {
                        
                        while self.mmio_read(0x18) & (1 << 5) != 0 {}
                        self.mmio_write(0x00, c as u32);
                    }
                
                    pub fn puts(&self, s: &str) {
                        for b in s.bytes() {
                            if b == b'\n' {
                                self.putc(b'\r');
                            }
                            self.putc(b);
                        }
                    }
                }
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ uart16550.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use crate::hal::Uart;
                
                pub struct Uart16550 {
                    base: usize,
                }
                
                impl Uart16550 {
                    pub const unsafe fn new(base: usize) -> Self {
                        Self { base }
                    }
                    
                    fn mmio_write(&self, reg: usize, value: u8) {
                        unsafe { (self.base + reg) as *mut u8 }.write_volatile(value);
                    }
                    
                    fn mmio_read(&self, reg: usize) -> u8 {
                        unsafe { (self.base + reg) as *const u8 }.read_volatile()
                    }
                }
                
                impl Uart for Uart16550 {
                    fn init(&mut self) {
                        
                        self.mmio_write(1, 0x00); 
                        self.mmio_write(3, 0x80); 
                        self.mmio_write(0, 0x03); 
                        self.mmio_write(1, 0x00);
                        self.mmio_write(3, 0x03);
                        self.mmio_write(2, 0xC7);
                    }
                    
                    fn putc(&mut self, c: u8) {
                        while self.mmio_read(5) & 0x20 == 0 {}
                        self.mmio_write(0, c);
                    }
                    
                    fn getc(&mut self) -> Option<u8> {
                        if self.mmio_read(5) & 0x01 != 0 {
                            Some(self.mmio_read(0))
                        } else {
                            None
                        }
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“ usb
                ğŸ“„ ehci.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub struct Ehci {
                    base: usize,
                }
                
                impl Ehci {
                    pub fn new(base: usize) -> Self {
                        Ehci { base }
                    }
                
                    pub fn init(&self) {
                        
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ mod.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub mod ehci;
                pub mod xhci;                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ xhci.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub struct Xhci {
                    base: usize,
                }
                
                impl Xhci {
                    pub fn new(base: usize) -> Self {
                        Xhci { base }
                    }
                
                    pub fn init(&self) {
                        
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ“ ppm-core
        ğŸ“„ Cargo.toml
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        [package]
        name = "ppm-core"
        version = "0.1.0"
        edition = "2021"
        
        [dependencies]
        serde = { version = "1.0.228", features = ["derive"] }
        toml = "0.9.8"
        sha2 = "0.10.9"
        ed25519-dalek = "2.2.0"
        anyhow = "1.0.100"
        thiserror = "2.0.17"
        plum-formats = { path = "../plum-formats" }
        plum-abi = { path = "../plum-abi" }
        rand = "0.9.2"
        clap = { version = "4.5.51", optional = true }
        dirs = "6.0.0"
        tokio = { version = "1.48.0", features = ["fs"], optional = true }
        
        [features]
        default = ["cli"]
        cli = ["dep:clap", "dep:tokio"]        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        ğŸ“ src
            ğŸ“„ architecture.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use serde::{Deserialize, Serialize};
            
            #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
            pub enum Architecture {
                #[serde(rename = "x86_64")]
                X86_64,
                #[serde(rename = "aarch64")]
                AArch64,
                #[serde(rename = "riscv64")]
                RiscV64,
                #[serde(rename = "prum64")]
                Prum64,
            }
            
            impl Architecture {
                pub fn current() -> Self {
                    match std::env::consts::ARCH {
                        "x86_64" => Architecture::X86_64,
                        "aarch64" => Architecture::AArch64,
                        "riscv64" => Architecture::RiscV64,
                        _ => Architecture::Prum64,
                    }
                }
            
                pub fn as_str(&self) -> &'static str {
                    match self {
                        Architecture::X86_64 => "x86_64",
                        Architecture::AArch64 => "aarch64",
                        Architecture::RiscV64 => "riscv64",
                        Architecture::Prum64 => "prum64",
                    }
                }
            
                pub fn supported_architectures() -> Vec<Self> {
                    vec![
                        Architecture::X86_64,
                        Architecture::AArch64,
                        Architecture::RiscV64,
                        Architecture::Prum64,
                    ]
                }
            }
            
            impl std::fmt::Display for Architecture {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }
            
            use std::str::FromStr;
            
            impl FromStr for Architecture {
                type Err = String;
            
                fn from_str(s: &str) -> Result<Self, Self::Err> {
                    match s {
                        "x86_64" => Ok(Architecture::X86_64),
                        "aarch64" => Ok(Architecture::AArch64),
                        "riscv64" => Ok(Architecture::RiscV64),
                        "prum64" => Ok(Architecture::Prum64),
                        _ => Err(format!("Unknown architecture: {}", s)),
                    }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ channel.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use serde::{Deserialize, Serialize};
            
            #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
            pub enum Channel {
                #[serde(rename = "stable")]
                Stable,
                #[serde(rename = "testing")]
                Testing,
                #[serde(rename = "unstable")]
                Unstable,
                #[serde(rename = "dev")]
                Dev,
            }
            
            impl Channel {
                pub fn name(&self) -> &'static str {
                    match self {
                        Channel::Stable => "stable",
                        Channel::Testing => "testing",
                        Channel::Unstable => "unstable",
                        Channel::Dev => "dev",
                    }
                }
            
                pub fn emoji(&self) -> &'static str {
                    match self {
                        Channel::Stable => "ğŸ‘",
                        Channel::Testing => "ğŸŒ¸",
                        Channel::Unstable => "ğŸŒ¾",
                        Channel::Dev => "ğŸ§ª",
                    }
                }
            
                pub fn display_name(&self) -> &'static str {
                    match self {
                        Channel::Stable => "Plum (Stable)",
                        Channel::Testing => "Blossom (Testing)",
                        Channel::Unstable => "Seed (Unstable)",
                        Channel::Dev => "Development",
                    }
                }
            
                pub fn all_channels() -> Vec<Self> {
                    vec![Channel::Stable, Channel::Testing, Channel::Unstable, Channel::Dev]
                }
            }
            
            impl std::fmt::Display for Channel {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{} {}", self.emoji(), self.display_name())
                }
            }
            
            use std::str::FromStr;
            
            impl FromStr for Channel {
                type Err = String;
            
                fn from_str(s: &str) -> Result<Self, Self::Err> {
                    match s {
                        "stable" => Ok(Channel::Stable),
                        "testing" => Ok(Channel::Testing),
                        "unstable" => Ok(Channel::Unstable),
                        "dev" => Ok(Channel::Dev),
                        _ => Err(format!("Unknown channel: {}", s)),
                    }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ config.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use serde::{Deserialize, Serialize};
            
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct Config {
                pub repository_url: String,
                pub cache_dir: String,
                pub keyring_dir: String,
                pub architecture: crate::Architecture,
                pub channel: crate::Channel,
            }
            
            impl Default for Config {
                fn default() -> Self {
                    Self {
                        repository_url: "https://repo.plumos.dev".to_string(),
                        cache_dir: "/var/cache/ppm".to_string(),
                        keyring_dir: "/etc/ppm/keys".to_string(),
                        architecture: crate::Architecture::current(),
                        channel: crate::Channel::Stable,
                    }
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ error.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use thiserror::Error;
            
            #[derive(Error, Debug)]
            pub enum PpmError {
                #[error("I/O error: {0}")]
                Io(#[from] std::io::Error),
                
                #[error("Serialization error: {0}")]
                Serialization(String), // Changed from serde_json::Error
                
                #[error("Signature verification failed: {0}")]
                Signature(#[from] ed25519_dalek::SignatureError),
                
                #[error("Invalid package format: {0}")]
                InvalidPackage(String),
                
                #[error("Package not found: {0}")]
                PackageNotFound(String),
                
                #[error("Dependency resolution failed: {0}")]
                DependencyResolution(String),
                
                #[error("Security violation: {0}")]
                SecurityViolation(String),
            }
            
            pub type Result<T> = std::result::Result<T, PpmError>;            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“ formats
                ğŸ“„ mod.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pub mod plpm;
                
                pub use plpm::PlpmPackage;                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                ğŸ“„ plpm.rs
                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                use serde::{Deserialize, Serialize};
                use crate::{Package, PackageMetadata, Architecture, Channel};
                
                /// Plum Package Manager Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ¿Ğ°ĞºĞµÑ‚Ğ° (.plpm)
                #[derive(Debug, Clone, Serialize, Deserialize)]
                pub struct PlpmPackage {
                    pub header: PlpmHeader,
                    pub metadata: PackageMetadata,
                    pub files: Vec<PlpmFile>,
                    pub scripts: Option<PlpmScripts>,
                    pub signature: Option<String>, // Changed from Vec<u8> to String
                }
                
                #[derive(Debug, Clone, Serialize, Deserialize)]
                pub struct PlpmHeader {
                    pub magic: [u8; 4],  // "PLPM"
                    pub version: u16,
                    pub architecture: Architecture,
                    pub channel: Channel,
                    pub compressed: bool,
                }
                
                #[derive(Debug, Clone, Serialize, Deserialize)]
                pub struct PlpmFile {
                    pub path: String,
                    pub data: Vec<u8>,
                    pub permissions: u32,
                    pub checksum: String,
                }
                
                #[derive(Debug, Clone, Serialize, Deserialize)]
                pub struct PlpmScripts {
                    pub pre_install: Option<String>,
                    pub post_install: Option<String>,
                    pub pre_remove: Option<String>,
                    pub post_remove: Option<String>,
                }
                
                impl PlpmPackage {
                    pub fn new(package: Package, files: Vec<PlpmFile>) -> Self {
                        Self {
                            header: PlpmHeader {
                                magic: *b"PLPM",
                                version: 1,
                                architecture: package.architecture,
                                channel: package.channel,
                                compressed: true,
                            },
                            metadata: PackageMetadata {
                                name: package.name,
                                version: package.version,
                                description: package.description,
                                author: package.author,
                                license: package.license,
                                dependencies: package.dependencies,
                                architectures: vec![package.architecture],
                                channels: vec![package.channel],
                                build_script: None,
                                install_script: None,
                                sandbox_config: None,
                            },
                            files,
                            scripts: None,
                            signature: package.signature,
                        }
                    }
                }                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ lib.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            pub mod architecture;
            pub mod channel;
            pub mod config;
            pub mod package;
            pub mod security;
            pub mod repository;
            pub mod error;
            pub mod formats;
            
            pub use architecture::Architecture;
            pub use channel::Channel;
            pub use config::Config;
            pub use package::{Package, PackageMetadata, PackageIndex};
            pub use security::{verify_signature, compute_checksum, generate_keypair};
            pub use error::{Result, PpmError};
            pub use repository::{Repository, RepositoryManager};
            
            pub use plum_formats::plam;
            
            #[cfg(not(target_os = "none"))]
            pub mod operations;
            #[cfg(not(target_os = "none"))]
            pub use operations::{
                load_config,
                install_package,
                remove_package,
                update_packages,
                search_packages,
                show_package_info,
                list_packages,
                check_updates,
                clean_cache,
            };            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ operations.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use crate::{
                Config, Package, Channel, Architecture, RepositoryManager, Repository,
                Result, PpmError, compute_checksum,
            };
            use std::path::Path;
            use tokio::fs;
            
            const DEFAULT_REPO_URL: &str = "https://repo.plumos.dev";
            
            pub async fn load_config() -> Result<Config> {
                let config_path = dirs::config_dir()
                    .unwrap_or_else(|| Path::new("/etc").to_path_buf())
                    .join("ppm/config.toml");
            
                if config_path.exists() {
                    let contents = fs::read_to_string(&config_path).await?;
                    let config: Config = toml::from_str(&contents)
                        .map_err(|e| PpmError::Serialization(e.to_string()))?;
                    Ok(config)
                } else {
                    let config = Config::default();
                    save_config(&config).await?;
                    Ok(config)
                }
            }
            
            pub async fn save_config(config: &Config) -> Result<()> {
                let config_dir = dirs::config_dir()
                    .unwrap_or_else(|| Path::new("/etc").to_path_buf())
                    .join("ppm");
                fs::create_dir_all(&config_dir).await?;
                let config_path = config_dir.join("config.toml");
                let contents = toml::to_string_pretty(config)
                    .map_err(|e| PpmError::Serialization(e.to_string()))?;
                fs::write(&config_path, contents).await?;
                Ok(())
            }
            
            async fn get_repo_manager(config: &Config) -> Result<RepositoryManager> {
                let mut manager = RepositoryManager::new();
                let architectures = vec![config.architecture];
                let repo = Repository::new(
                    DEFAULT_REPO_URL.to_string(),
                    "main".to_string(),
                    config.channel,
                    architectures,
                );
                manager.add_repository(repo);
                // Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸ Ğ¸Ğ· ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³Ğ°, ĞµÑĞ»Ğ¸ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚Ğµ Ğ¸Ñ… Ğ¿Ğ¾Ğ·Ğ¶Ğµ
                Ok(manager)
            }
            
            pub async fn install_package(
                package_name: &str,
                version: Option<&str>,
                channel: Option<Channel>,
                arch: Option<Architecture>,
                _deps: bool,
                _sandbox: bool,
                _force: bool,
                config: &Config,
            ) -> Result<()> {
                let ch = channel.unwrap_or(config.channel);
                let arch = arch.unwrap_or(config.architecture);
                let manager = get_repo_manager(config).await?;
                if let Some(pkg) = manager.find_package_across_repos(package_name, version)? {
                    if pkg.channel == ch && pkg.architecture == arch {
                        println!("ğŸ“¥ Installing {}-{} ({})", pkg.name, pkg.version, pkg.file);
                        // Ğ—Ğ´ĞµÑÑŒ Ğ±ÑƒĞ´ĞµÑ‚ Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ°Ñ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°: ÑĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°, Ñ€Ğ°ÑĞ¿Ğ°ĞºĞ¾Ğ²ĞºĞ°
                        Ok(())
                    } else {
                        Err(PpmError::PackageNotFound(format!(
                            "No {} package for {} in {} channel", package_name, arch.as_str(), ch.name()
                        )))
                    }
                } else {
                    Err(PpmError::PackageNotFound(package_name.to_string()))
                }
            }
            
            pub async fn remove_package(package_name: &str, _force: bool, _config: &Config) -> Result<()> {
                println!("ğŸ—‘ï¸ Removing package: {}", package_name);
                // Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°: ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ², Ğ·Ğ°Ğ¿ÑƒÑĞº post-remove ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ° Ğ¸ Ñ‚.Ğ´.
                Ok(())
            }
            
            pub async fn update_packages(
                package_name: Option<&str>,
                channel: Option<Channel>,
                config: &Config,
            ) -> Result<()> {
                let ch = channel.unwrap_or(config.channel);
                println!("ğŸ”„ Updating packages in {} channel...", ch.name());
                if let Some(name) = package_name {
                    println!(" Target: {}", name);
                }
                // Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ²ĞµÑ€ÑĞ¸Ğ¹, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ
                Ok(())
            }
            
            pub async fn search_packages(query: &str, channel: Option<Channel>, config: &Config) -> Result<()> {
                let ch = channel.unwrap_or(config.channel);
                println!("ğŸ” Searching for '{}' in {} channel...", query, ch.name());
                // Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ¸Ğ½Ğ´ĞµĞºÑÑƒ
                Ok(())
            }
            
            pub async fn show_package_info(package_name: &str, config: &Config) -> Result<()> {
                println!("ğŸ“„ Showing info for package: {}", package_name);
                // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ¸Ğ½Ğ´ĞµĞºÑĞ°
                Ok(())
            }
            
            pub async fn list_packages(channel: Option<Channel>, config: &Config) -> Result<()> {
                let ch = channel.unwrap_or(config.channel);
                println!("ğŸ“‹ Listing packages in {} channel...", ch.name());
                // Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ² (Ğ¸Ğ· /var/lib/ppm/db Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ğ¾Ğ³Ğ¾)
                Ok(())
            }
            
            pub async fn check_updates(channel: Option<Channel>, config: &Config) -> Result<()> {
                let ch = channel.unwrap_or(config.channel);
                println!("âœ… Checking for updates in {} channel...", ch.name());
                // Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ÑŒ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ²ĞµÑ€ÑĞ¸Ğ¸ Ñ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸ĞµĞ¼
                Ok(())
            }
            
            pub async fn clean_cache(all: bool, config: &Config) -> Result<()> {
                let cache_dir = &config.cache_dir;
                if all {
                    println!("ğŸ§¹ Cleaning entire cache at {}", cache_dir);
                    // Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘ Ğ² ĞºÑÑˆĞµ
                } else {
                    println!("ğŸ§¹ Cleaning old cache entries...");
                    // Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ²ÑˆĞ¸Ğµ
                }
                Ok(())
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ package.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use serde::{Deserialize, Serialize};
            use crate::{Architecture, Channel};
            
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct Package {
                pub name: String,
                pub version: String,
                pub description: Option<String>,
                pub author: Option<String>,
                pub license: Option<String>,
                pub dependencies: Vec<String>,
                pub architecture: Architecture,
                pub channel: Channel,
                pub file: String,
                pub checksum: String,
                pub signature: Option<String>,
                pub size: u64,
                pub install_size: u64,
            }
            
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct PackageMetadata {
                pub name: String,
                pub version: String,
                pub description: Option<String>,
                pub author: Option<String>,
                pub license: Option<String>,
                pub dependencies: Vec<String>,
                pub architectures: Vec<Architecture>,
                pub channels: Vec<Channel>,
                pub build_script: Option<String>,
                pub install_script: Option<String>,
                pub sandbox_config: Option<SandboxConfig>,
            }
            
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct SandboxConfig {
                pub allowed_paths: Vec<String>,
                pub network_access: bool,
                pub system_calls: Vec<String>,
            }
            
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct PackageIndex {
                pub packages: Vec<Package>,
                pub generated: String,
                pub channel: Channel,
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ repository.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use crate::{Package, Channel, Architecture, Result};
            use crate::package::PackageIndex;
            
            #[derive(Debug, Clone)]
            pub struct Repository {
                pub url: String,
                pub name: String,
                pub channel: Channel,
                pub architectures: Vec<Architecture>,
            }
            
            impl Repository {
                pub fn new(url: String, name: String, channel: Channel, architectures: Vec<Architecture>) -> Self {
                    Self {
                        url,
                        name,
                        channel,
                        architectures,
                    }
                }
            
                pub async fn fetch_index(&self) -> Result<PackageIndex> {
                    // TODO: Implement actual HTTP fetching
                    // For now, return an empty index with current timestamp
                    Ok(PackageIndex {
                        packages: Vec::new(),
                        generated: std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap()
                            .as_secs()
                            .to_string(),
                        channel: self.channel,
                    })
                }
            
                pub fn supported_architectures(&self) -> &[Architecture] {
                    &self.architectures
                }
            
                pub fn find_package(&self, _name: &str, _version: Option<&str>) -> Result<Option<Package>> {
                    // TODO: Implement package lookup
                    Ok(None)
                }
            }
            
            pub struct RepositoryManager {
                repositories: Vec<Repository>,
            }
            
            impl RepositoryManager {
                pub fn new() -> Self {
                    Self {
                        repositories: Vec::new(),
                    }
                }
            
                pub fn add_repository(&mut self, repo: Repository) {
                    self.repositories.push(repo);
                }
            
                pub fn get_repositories(&self) -> &[Repository] {
                    &self.repositories
                }
            
                pub fn find_package_across_repos(&self, name: &str, version: Option<&str>) -> Result<Option<Package>> {
                    for repo in &self.repositories {
                        if let Some(pkg) = repo.find_package(name, version)? {
                            return Ok(Some(pkg));
                        }
                    }
                    Ok(None)
                }
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ğŸ“„ security.rs
            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            use ed25519_dalek::{Signature, VerifyingKey, SigningKey, SignatureError, Verifier};
            use sha2::{Sha256, Digest};
            
            #[cfg(not(target_os = "none"))]
            use rand::RngCore;
            
            pub fn verify_signature(data: &[u8], signature: &[u8], public_key: &[u8]) -> Result<(), SignatureError> {
                // Convert public_key to [u8; 32]
                let public_key_array: [u8; 32] = public_key
                    .try_into()
                    .map_err(|_| SignatureError::new())?;
            
                // Convert signature to [u8; 64]
                let signature_array: [u8; 64] = signature
                    .try_into()
                    .map_err(|_| SignatureError::new())?;
            
                // Create verifying key from raw bytes
                let verifying_key = VerifyingKey::from_bytes(&public_key_array)?;
            
                // Create signature object
                let signature_obj = Signature::from_bytes(&signature_array);
            
                // Verify signature using the `Verifier` trait (now in scope)
                verifying_key.verify(data, &signature_obj)
            }
            
            pub fn compute_checksum(data: &[u8]) -> String {
                let mut hasher = Sha256::new();
                hasher.update(data);
                format!("{:x}", hasher.finalize())
            }
            
            pub fn generate_keypair() -> (SigningKey, VerifyingKey) {
                let mut secret_key_bytes = [0u8; 32];
            
                #[cfg(not(target_os = "none"))]
                {
                    let mut rng = rand::thread_rng();
                    rng.fill_bytes(&mut secret_key_bytes);
                }
            
                #[cfg(target_os = "none")]
                {
                    // Fallback for no_std environments (non-cryptographic!)
                    for i in 0..32 {
                        secret_key_bytes[i] = (i * 7) as u8;
                    }
                }
            
                let signing_key = SigningKey::from_bytes(&secret_key_bytes);
                let verifying_key = signing_key.verifying_key();
                (signing_key, verifying_key)
            }            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ templates
